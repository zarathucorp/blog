{
  "hash": "84ab9bdfd4cbfbf7a4ed24d5893f792b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"collapse 패키지 소개 v2\"\ndescription: | \n  collapse; fast, flexible, parsimonoius code package for R.\ncategories:\n  - R\n  - statistics\n  - data.table\nauthor:\n  name: \"Hojun LEE\"\n  url: https://github.com/21-HJ\nimage: img/logo.png\nfig_width: 400\ndate: 2024-10-29\nformat: html\nexecute:\n  freeze: true\ndraft: false\nlicense: CC BY-NC\n\n---\n\n\n\n```         \n```\n\n# Introduction\n\n-   **Collapse**\n    1.  C/C++ 기반의 패키지로 큰 데이터셋을 보다 쉽게 다룰 수 있도록 구성됨.\n\n    2.  R code의 성능을 획기적으로 개선하여 대규모 데이터를 **빠르고 효율적**으로 처리함을 목표로 함.\n\n    3.  성능을 극대화함과 동시에, 기존 데이터 조작 framework와 통합할 수 있도록 안정적이고 최적화된 사용자 API를 제공함. \n        (dplyr, tidyverse, data.table 등)\n-   **MAIN FOCUS** -\\> **data.table**과 함께 이용하여 보다 빠르게 연산을 처리하자.\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##setup\n\n#install.packages(\"collapse\")\n\nlibrary(magrittr);library(dplyr);library(data.table) \n\nlibrary(collapse);library(microbenchmark);library(lmtest)\n```\n:::\n\n\n\n## Basic\n\ndata.table처럼 fread & fwrite를 이용하여 csv파일을 처리한다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exam data: 09-15\n\ndt <- fread(\"https://raw.githubusercontent.com/jinseob2kim/lecture-snuhlab/master/data/example_g1e.csv\")\ndf <- read.csv(\"https://raw.githubusercontent.com/jinseob2kim/lecture-snuhlab/master/data/example_g1e.csv\")\nfwrite(dt, \"aa.csv\")\n```\n:::\n\n\n\n**Columns**: **'fselect'**로 원하는 열을 불러올 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfselect(dt, 1:3, 13:16) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  334536     200911   162    51    63  19.4\n3:         2009  911867     200903   163    65    82  24.5\n4:         2009  183321     200908   152    51    70  22.1\n5:         2009  942671     200909   159    50    73  19.8\n6:         2009  979358     200912   157    55    73  22.3\n```\n\n\n:::\n\n```{.r .cell-code}\nfselect(dt, EXMD_BZ_YYYY,RN_INDI,HME_YYYYMM )|> head() # fselect(dt, \"EXMD_BZ_YYYY\",\"RN_INDI\",\"HME_YYYYMM\" )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM\n          <int>   <int>      <int>\n1:         2009  562083     200909\n2:         2009  334536     200911\n3:         2009  911867     200903\n4:         2009  183321     200908\n5:         2009  942671     200909\n6:         2009  979358     200912\n```\n\n\n:::\n:::\n\n\n\n**Rows**: **'fsubset()'**로 원하는 행/열을 불러올 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfsubset(dt, 1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM Q_PHX_DX_STK Q_PHX_DX_HTDZ Q_PHX_DX_HTN\n          <int>   <int>      <int>        <int>         <int>        <int>\n1:         2009  562083     200909            0             0            1\n2:         2009  334536     200911            0             0            0\n3:         2009  911867     200903            0             0            0\n   Q_PHX_DX_DM Q_PHX_DX_DLD Q_PHX_DX_PTB Q_HBV_AG Q_SMK_YN Q_DRK_FRQ_V09N  HGHT\n         <int>        <int>        <int>    <int>    <int>          <int> <int>\n1:           0            0           NA        3        1              0   144\n2:           0            0           NA        2        1              0   162\n3:           0            0           NA        3        1              0   163\n    WGHT  WSTC   BMI VA_LT VA_RT BP_SYS BP_DIA URN_PROT   HGB   FBS TOT_CHOL\n   <int> <int> <num> <num> <num>  <int>  <int>    <int> <num> <int>    <int>\n1:    61    90  29.4   0.7   0.8    120     80        1  12.6   117      264\n2:    51    63  19.4   0.8   1.0    120     80        1  13.8    96      169\n3:    65    82  24.5   0.7   0.6    130     80        1  15.0   118      216\n      TG   HDL   LDL  CRTN  SGOT  SGPT   GGT   GFR\n   <int> <int> <int> <num> <int> <int> <int> <int>\n1:   128    60   179   0.9    25    20    25    59\n2:    92    70    80   0.9    18    15    28    74\n3:   132    55   134   0.8    26    30    30    79\n```\n\n\n:::\n\n```{.r .cell-code}\n#fsubset(dt, c(1:3, 13:16)) #rows\nfsubset(dt, 1:3, 13:16)  #(dt, row, col)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    HGHT  WGHT  WSTC   BMI\n   <int> <int> <int> <num>\n1:   144    61    90  29.4\n2:   162    51    63  19.4\n3:   163    65    82  24.5\n```\n\n\n:::\n\n```{.r .cell-code}\nfsubset(dt, c(1:nrow(dt)),c(1:3, 13:16)) |> head() #cols\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  334536     200911   162    51    63  19.4\n3:         2009  911867     200903   163    65    82  24.5\n4:         2009  183321     200908   152    51    70  22.1\n5:         2009  942671     200909   159    50    73  19.8\n6:         2009  979358     200912   157    55    73  22.3\n```\n\n\n:::\n\n```{.r .cell-code}\n# fsubset(dt, EXMD_BZ_YYYY %in% 2009:2012 & BMI >= 25) %>%  fsubset(c(1:3),c(1:3,13:16))\nfsubset(dt, c(1:nrow(dt)),c(1:3, 13:16)) %>% fsubset(EXMD_BZ_YYYY %in% 2009:2012 & BMI >= 25) |> head() # same\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  318669     200904   155    66    78  27.5\n3:         2009  668438     200904   160    71    94  27.7\n4:         2009  560878     200903   144    58    93  28.0\n5:         2009  375694     200906   151    70    94  30.7\n6:         2009  446652     200909   158    64    80  25.6\n```\n\n\n:::\n\n```{.r .cell-code}\nroworder(dt, HGHT) %>% fsubset(EXMD_BZ_YYYY %in% 2009:2012 & BMI >= 25) %>%\n  fsubset(c(1:nrow(dt)),c(1:3,13:16)) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   EXMD_BZ_YYYY RN_INDI HME_YYYYMM  HGHT  WGHT  WSTC   BMI\n          <int>   <int>      <int> <int> <int> <int> <num>\n1:         2009  562083     200909   144    61    90  29.4\n2:         2009  560878     200903   144    58    93  28.0\n3:         2011  562083     201111   144    59    88  28.5\n4:         2011  519824     201109   145    58    79  27.6\n5:         2011  914987     201103   145    70    95  33.3\n6:         2012  560878     201208   145    59    85  28.1\n```\n\n\n:::\n:::\n\n\n\n# Collapse package\n\n지금까지 collapse에서의 행/열 처리에 대해 알아보았다. 다음은 collapse에서 보다 빠른 연산 및 데이터 처리를 도와주는 도구들이다.\n\n## Fast Statistical Function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.FAST_STAT_FUN\n # [1]  \"fmean\"      \"fmedian\"    \"fmode\"      \"fsum\"       \"fprod\"      \n # [6]  \"fsd\"        \"fvar\"       \"fmin\"       \"fmax\"       \"fnth\"       \n # [11] \"ffirst\"     \"flast\"      \"fnobs\"      \"fndistinct\"\n\n# 데이터 구조에 구애받지않음.\nv1 <- c(1,2,3,4)\nm1 <- matrix(1:50, nrow = 10, ncol = 5)\n \nfmean(v1); fmean(m1); fmean(dt)\nfmode(v1); fmode(m1); fmode(dt)\n# fmean(m1): by columns\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# collapse; baseR과 비교했을 때 보다 빠른 속도를 보인다.\nx <- rnorm(1e7)\nmicrobenchmark(mean(x), fmean(x), fmean(x, nthreads = 4)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                   expr       min        lq      mean    median        uq\n                mean(x) 23.818189 23.881988 23.920430 23.913170 23.947722\n               fmean(x) 15.334012 15.392979 15.428531 15.429847 15.449727\n fmean(x, nthreads = 4)  4.025523  6.862578  7.695351  7.864132  8.486929\n      max neval cld\n 24.09041   100 a  \n 15.58527   100  b \n 10.64787   100   c\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(colMeans(dt), sapply(dt, mean), fmean(dt))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n             expr      min        lq      mean    median       uq      max\n     colMeans(dt) 3154.642 3301.1200 3295.8407 3304.7220 3309.081 3593.496\n sapply(dt, mean)  190.719  196.3270  208.5230  206.0745  216.491  270.384\n        fmean(dt)   52.694   53.7125   56.1483   55.6745   56.788   86.429\n neval cld\n   100 a  \n   100  b \n   100   c\n```\n\n\n:::\n:::\n\n\n\n-   Data size가 더 클 경우, 보다 유용하다. *(GGDC10S: 5000rows, 11cols, ~10% missing values)*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(base = sapply(GGDC10S[6:16], mean, na.rm = TRUE), fmean(GGDC10S[6:16]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                 expr     min       lq     mean   median       uq      max\n                 base 409.223 419.1965 659.1579 433.2085 813.6440 4242.667\n fmean(GGDC10S[6:16])  94.504  95.5710 100.6444 102.1360 103.8795  135.503\n neval cld\n   100  a \n   100   b\n```\n\n\n:::\n:::\n\n\n\n-   이처럼, **Collapse**는 data 형식에 구애받지 않고, 보다 빠른 속도를 특징으로 하는 package이다.\n\n이들의 문법을 알아보자.\n\n```         \n-   Fast Statistical Functions\n\n  Syntax:\n\nFUN(x, g = NULL, \\[w = NULL,\\] TRA = NULL, \\[na.rm = TRUE\\], use.g.names = TRUE, \\[drop = TRUE,\\] \\[nthreads = 1,\\] ...)\n\n       \nArgument            Description\n      g             grouping vectors / lists of vectors or ’GRP’ object\n      w             a vector of (frequency) weights\n    TRA             a quoted operation to transform x using the statistics\n  na.rm             efficiently skips missing values in x\n  use.g.names       generate names/row-names from g\n  drop              drop dimensions if g = TRA = NULL\n  nthreads          number of threads for OpenMP multithreading\n```\n\n**사용예시** : **fmean**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Weighted Mean\nw <- abs(rnorm(nrow(iris)))\nall.equal(fmean(num_vars(iris), w = w), sapply(num_vars(iris), weighted.mean, w = w))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nwNA <- na_insert(w, prop = 0.05)\nsapply(num_vars(iris), weighted.mean, w = wNA) # weighted.mean(): 결측치를 처리하지 못한다.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n          NA           NA           NA           NA \n```\n\n\n:::\n\n```{.r .cell-code}\nfmean(num_vars(iris), w = wNA) #결측치를 자동으로 무시한다.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.766455     3.088102     3.558861     1.107960 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Grouped Mean\nfmean(iris$Sepal.Length, g = iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    setosa versicolor  virginica \n     5.006      5.936      6.588 \n```\n\n\n:::\n\n```{.r .cell-code}\nfmean(num_vars(iris), iris$Species)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa            5.006       3.428        1.462       0.246\nversicolor        5.936       2.770        4.260       1.326\nvirginica         6.588       2.974        5.552       2.026\n```\n\n\n:::\n\n```{.r .cell-code}\n# Weighted Group Mean\nfmean(num_vars(iris), iris$Species, w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa         5.033403    3.434271     1.464525   0.2377769\nversicolor     5.941119    2.783020     4.263050   1.3291146\nvirginica      6.499996    2.965439     5.492447   2.0008032\n```\n\n\n:::\n\n```{.r .cell-code}\n# 속도 상의 이점. \nmicrobenchmark(fmean = fmean(iris$Sepal.Length, iris$Species),\n               tapply = tapply(iris$Sepal.Length, iris$Species, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n   expr    min     lq     mean median      uq     max neval cld\n  fmean  7.531  7.862  8.54733  8.239  8.4255  41.448   100  a \n tapply 47.166 48.190 49.66377 48.636 49.1180 123.933   100   b\n```\n\n\n:::\n:::\n\n\n\n## Consideration w/ missing data: 결측치 처리\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#wlddev$GINI, g: country, function: mean, median, min, max, sum, prod\ncollap(wlddev, GINI ~ country, list(mean, median, min, max, sum, prod),\n       na.rm = TRUE, give.names = FALSE) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         country     mean median  min  max   sum         prod\n1    Afghanistan      NaN     NA  Inf -Inf   0.0 1.000000e+00\n2        Albania 31.41111   31.7 27.0 34.6 282.7 2.902042e+13\n3        Algeria 34.36667   35.3 27.6 40.2 103.1 3.916606e+04\n4 American Samoa      NaN     NA  Inf -Inf   0.0 1.000000e+00\n5        Andorra      NaN     NA  Inf -Inf   0.0 1.000000e+00\n6         Angola 48.66667   51.3 42.7 52.0 146.0 1.139065e+05\n```\n\n\n:::\n\n```{.r .cell-code}\n# na.rm=T가 기본값이며, NA를 연산한 값은 모두 NA를 결과값으로 반영함. \ncollap(wlddev, GINI ~ country, list(fmean, fmedian, fmin, fmax, fsum, fprod),\n       give.names = FALSE) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         country    fmean fmedian fmin fmax  fsum        fprod\n1    Afghanistan       NA      NA   NA   NA    NA           NA\n2        Albania 31.41111    31.7 27.0 34.6 282.7 2.902042e+13\n3        Algeria 34.36667    35.3 27.6 40.2 103.1 3.916606e+04\n4 American Samoa       NA      NA   NA   NA    NA           NA\n5        Andorra       NA      NA   NA   NA    NA           NA\n6         Angola 48.66667    51.3 42.7 52.0 146.0 1.139065e+05\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(a = collap(wlddev, GINI ~ country, list(mean, median, min, max, sum, prod),\n                          na.rm = TRUE, give.names = FALSE) |> head(),\n               b=collap(wlddev, GINI ~ country, list(fmean, fmedian, fmin, fmax, fsum, fprod),\n                        give.names = FALSE) |> head())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr      min        lq       mean    median        uq       max neval cld\n    a 9854.603 9940.8865 10522.7090 10008.930 10297.669 14969.065   100  a \n    b  545.479  590.4145   611.5872   621.694   633.038   685.942   100   b\n```\n\n\n:::\n\n```{.r .cell-code}\n# 속도 상 이점을 다시 한 번 확인할 수 있다.\n```\n:::\n\n\n\n## TRA function\n\n-   TRA function을 이용, 여러 행/열의 연산을 간편하게 처리할 수 있다.\n\n```         \nSyntax:\n  TRA(x, STATS, FUN = \"-\", g = NULL, set = FALSE, ...)\n\n\n  setTRA(x, STATS, FUN = \"-\", g = NULL, ...)\n\n  STATS = vector/matrix/list of statistics\n\n0        \"replace_NA\"     replace missing values in x\n1        \"replace_fill\"   replace data and missing values in x\n2        \"replace\"        replace data but preserve missing values in x\n3        \"-\"              subtract (i.e. center)\n4        \"-+\"             center on overall average statistic\n5        \"/\"              divide (i.e. scale)\n6        \"%\"              compute percentages (i.e. divide and multiply by 100)   \n7        \"+\"              add\n8        \"*\"              multiply\n9        \"%%\"             modulus (i.e. remainder from division by STATS)\n10       \"-%%\"            subtract modulus (i.e. make data divisible by STATS)\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt2 <- as.data.table(iris)\n\nattach(iris)    #data.table에서처럼 변수명을 직접 호출하기 위해 attach를 사용할 수 있다.\n\n# 평균값과의 차: g= Species\nall_obj_equal(Sepal.Length - ave(Sepal.Length, g = Species),\n              fmean(Sepal.Length, g = Species, TRA= \"-\"),\n              TRA(Sepal.Length, fmean(Sepal.Length, g = Species), \"-\", g = Species))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(baseR= Sepal.Length - ave(Sepal.Length, g = Species),\n               fmean = mean(Sepal.Length, g = Species, TRA= \"-\"),\n               TRA_fmean = TRA(Sepal.Length, fmean(Sepal.Length, g = Species), \"-\", g = Species));detach(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n      expr    min      lq     mean  median      uq     max neval cld\n     baseR 57.077 58.4975 60.77960 59.4215 60.3085 159.264   100 a  \n     fmean  3.796  3.9900  4.18378  4.1510  4.2665   7.214   100  b \n TRA_fmean 11.882 12.3505 13.25294 12.7595 13.3165  44.254   100   c\n```\n\n\n:::\n:::\n\n\n\n-   **TRA()**를 사용하기보다 **Fast Statistical Function**에서 **TRA** 기능을 호출하자!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#예시\nnum_vars(dt2) %<>%  na_insert(prop = 0.05)\n\n# NA 값을 median값으로 대체.\nnum_vars(dt2) |> fmedian(iris$Species, TRA = \"replace_NA\", set = TRUE)\n# num_vars(dt2) |> fmean(iris$Species, TRA = \"replace_NA\", set = TRUE) --> mean으로 대체.\n\n\n# 다양한 연산 및 작업을 한 번에 다룰 수 있다.\nmtcars |> ftransform(A = fsum(mpg, TRA = \"%\"),\n                     B = mpg > fmedian(mpg, cyl, TRA = \"replace_fill\"),\n                     C = fmedian(mpg, list(vs, am), wt, \"-\"),\n                     D = fmean(mpg, vs,, 1L) > fmean(mpg, am,, 1L)) |> head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               mpg cyl disp  hp drat    wt  qsec vs am gear carb        A     B\nMazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 3.266449  TRUE\nMazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 3.266449  TRUE\nDatsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 3.546430 FALSE\n                 C     D\nMazda RX4      1.3 FALSE\nMazda RX4 Wag  1.3 FALSE\nDatsun 710    -7.6  TRUE\n```\n\n\n:::\n:::\n\n\n\n## Grouping Object\n\n-   GRP function을 이용, group을 쉽게 연산할 수 있다.\n\n    ```         \n    Syntax:\n\n        GRP(X, by = NULL, sort == TRUE, decreasing = FALSE, na.last = TRUE, \n        return.groups = TRUE, return.order = sort, method = \"auto\", ...)\n    ```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- GRP(iris, by = ~ Species)\nprint(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncollapse grouping object of length 150 with 3 ordered groups\n\nCall: GRP.default(X = iris, by = ~Species), X is sorted\n\nDistribution of group sizes: \n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n     50      50      50      50      50      50 \n\nGroups with sizes: \n    setosa versicolor  virginica \n        50         50         50 \n```\n\n\n:::\n\n```{.r .cell-code}\nstr(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClass 'GRP'  hidden list of 9\n $ N.groups    : int 3\n $ group.id    : int [1:150] 1 1 1 1 1 1 1 1 1 1 ...\n $ group.sizes : int [1:3] 50 50 50\n $ groups      :'data.frame':\t3 obs. of  1 variable:\n  ..$ Species: Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 2 3\n $ group.vars  : chr \"Species\"\n $ ordered     : Named logi [1:2] TRUE TRUE\n  ..- attr(*, \"names\")= chr [1:2] \"ordered\" \"sorted\"\n $ order       : int [1:150] 1 2 3 4 5 6 7 8 9 10 ...\n  ..- attr(*, \"starts\")= int [1:3] 1 51 101\n  ..- attr(*, \"maxgrpn\")= int 50\n  ..- attr(*, \"sorted\")= logi TRUE\n $ group.starts: int [1:3] 1 51 101\n $ call        : language GRP.default(X = iris, by = ~Species)\n```\n\n\n:::\n\n```{.r .cell-code}\n# GRP 기능- 호출하여 사용하자!\nfmean(num_vars(iris), g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa            5.006       3.428        1.462       0.246\nversicolor        5.936       2.770        4.260       1.326\nvirginica         6.588       2.974        5.552       2.026\n```\n\n\n:::\n\n```{.r .cell-code}\nfmean(num_vars(iris), iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Sepal.Length Sepal.Width Petal.Length Petal.Width\nsetosa            5.006       3.428        1.462       0.246\nversicolor        5.936       2.770        4.260       1.326\nvirginica         6.588       2.974        5.552       2.026\n```\n\n\n:::\n:::\n\n\n\n## Factors in operation\n\n**Collaspe**는 형식에 구애받지 않는다; factor를 바로 연산할 수 있으며, **qF**로 빠르게 factor를 생성할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- na_insert(rnorm(1e7), prop = 0.01) \ng <- sample.int(1e6, 1e7, TRUE)         \n# grp와 비교\nsystem.time(gg <- GRP(g))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.619   0.040   0.659 \n```\n\n\n:::\n\n```{.r .cell-code}\nsystem.time(f <- qF(g, na.exclude = FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.273   0.032   0.306 \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"      \"na.included\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(fmean(x, g), \n               fmean(x, gg), \n               fmean(x, gg, na.rm = FALSE), \n               fmean(x, f))\n ## Unit: milliseconds\n ##       expr                    min         lq          mean        median\n ## fmean(x, g)                   146.060983  150.493309  155.02585   152.197822\n ## fmean(x, gg)                  25.354564   27.709625   29.48497    29.022157\n ## fmean(x, gg, na.rm = FALSE)   13.184534   13.783585   15.61769    14.128067\n ## fmean(x, f)                   24.847271   27.503661   29.47271    29.248580\n\n# qF를 통해 grp와 유사한 성능 향상을 기대할 수 있다.\n```\n:::\n\n\n\n## Summary: FAST grouping and Ordering\n\n```         \n다양한 기능이 있다. \nGRP()           Fast sorted or unsorted grouping of multivariate data, returns detailed object of class ’GRP’ \nqF()/qG()       Fast generation of factors and quick-group (’qG’) objects from atomic vectors \nfinteraction()  Fast interactions: returns factor or ’qG’ objects \nfdroplevels()   Efficiently remove unused factor levels\n\nradixorder()    Fast ordering and ordered grouping \ngroup()         Fast first-appearance-order grouping: returns ’qG’ object \ngsplit()        Split vector based on ’GRP’ object \ngreorder()      Reorder the results\n\n- that also return ’qG’ objects \ngroupid()       Generalized run-length-type grouping seqid() Grouping of integer sequences \ntimeid()        Grouping of time sequences (based on GCD)\n\ndapply()        Apply a function to rows or columns of data.frame or matrix based objects. \nBY()            Apply a function to vectors or matrix/data frame columns by groups.\n\n-   Specialized Data Transformation Functions \nfbetween()      Fast averaging and (quasi-)centering. \nfwithin()\nfhdbetween()    Higher-Dimensional averaging/centering and linear prediction/partialling out \nfhdwithin()     (powered by fixest’s algorithm for multiple factors).\nfscale()        (advanced) scaling and centering.\n\n-   Time / Panel Series Functions \nfcumsum()       Cumulative sums \nflag()          Lags and leads \nfdiff()         (Quasi-, Log-, Iterated-) differences \nfgrowth()       (Compounded-) growth rates\n\n-    Data manipulation functions\nfselect(),      fsubset(),      fgroup_by(),    [f/set]transform[v](),          \nfmutate(),      fsummarise(),   across(),       roworder[v](),            \ncolorder[v](),  [f/set]rename(),                [set]relabel()\n```\n\n## Collapse는 빠르다!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfdim(wlddev)    ##faster dim for dt. col/row: 13176 13\n\n# 1990년 이후를 기준으로, ODA/POP의 값 (g: region, income, OECD)\nmicrobenchmark( \n  \ndplyr = qDT(wlddev) |>\n        filter(year >= 1990) |>\n        mutate(ODA_POP = ODA / POP) |>\n        group_by(region, income, OECD) |>\n        summarise(across(PCGDP:POP, sum, na.rm = TRUE), .groups = \"drop\") |>\n        arrange(income, desc(PCGDP)),\n\ndata.table = qDT(wlddev)[, ODA_POP := ODA / POP][\n             year >= 1990, lapply(.SD, sum, na.rm = TRUE),\n             by = .(region, income, OECD), .SDcols = PCGDP:ODA_POP][\n             order(income, -PCGDP)],\n\ncollapse_base = qDT(wlddev) |>\n                fsubset(year >= 1990) |>\n                fmutate(ODA_POP = ODA / POP) |>\n                fgroup_by(region, income, OECD) |>\n                fsummarise(across(PCGDP:ODA_POP, sum, na.rm = TRUE)) |>\n                roworder(income, -PCGDP),\n\ncollapse_optimized = qDT(wlddev) |>\n                    fsubset(year >= 1990, region, income, OECD, PCGDP:POP) |>\n                    fmutate(ODA_POP = ODA / POP) |>\n                    fgroup_by(1:3, sort = FALSE) |> fsum() |>\n                    roworder(income, -PCGDP)\n)\n\n\n## Unit: microseconds\n##        expr            min         lq            mean            median          uq            max         neval\n## dplyr                  71955.523   72291.9715    80009.2208\t    72453.1165\t    76902.671   393947.262\t100\t\n## data.table\t          5960.503    6310.7045     7116.6673\t    6721.3450\t    7046.837    18615.736\t  100\t\n## collapse_base\t      859.505     948.2200      1041.1137\t    990.1375\t    1061.864\t 3148.804\t    100\t\n## collapse_optimized\t  442.040     482.9705      542.6927\t    523.6950\t    574.921\t    1036.817\t  100\t\n```\n:::\n\n\n\n## **Collapse** w/ Fast Statistical Function: 다양한 활용\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 아래 셋은 동일한 결과를 보인다.\n# cyl별 mpg sum\n mtcars %>% ftransform(mpg_sum = fsum(mpg, g = cyl, TRA = \"replace_fill\")) %>% invisible()\n mtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, GRP(.), TRA = \"replace_fill\")) %>% invisible()\n mtcars %>% fgroup_by(cyl) %>% fmutate(mpg_sum = fsum(mpg)) %>% head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl  disp  hp drat    wt  qsec vs am gear carb mpg_sum\nMazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4   138.2\nMazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4   138.2\nDatsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1   293.3\nHornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1   138.2\nHornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2   211.4\nValiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1   138.2\nDuster 360        14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4   211.4\nMerc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2   293.3\nMerc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2   293.3\nMerc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4   138.2\n```\n\n\n:::\n:::\n\n\n\n-   ad-hoc grouping, often **fastest!**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(a=mtcars %>% ftransform(mpg_sum = fsum(mpg, g = cyl, TRA = \"replace_fill\")),\n               b=mtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, GRP(.), TRA = \"replace_fill\")),\n               c=mtcars %>% fgroup_by(cyl) %>% fmutate(mpg_sum = fsum(mpg)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr    min      lq     mean  median      uq     max neval cld\n    a 27.266 29.7885 31.47125 30.4025 31.7165 107.002   100 a  \n    b 64.819 66.7990 68.84531 67.8300 68.8585 138.077   100  b \n    c 78.526 80.3145 82.11237 81.4460 82.3050 126.137   100   c\n```\n\n\n:::\n:::\n\n\n\n-   **ftransform()**은 앞의 **fgroupby**를 무시한다. 아래 둘은 값이 다르다. (**fmutate, fsummarise**만 이전 group을 반영한다.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, GRP(.), TRA = \"replace_fill\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_sum\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   138.2\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   138.2\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   293.3\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   138.2\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   211.4\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   138.2\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars %>% fgroup_by(cyl) %>% ftransform(mpg_sum = fsum(mpg, TRA = \"replace_fill\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_sum\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   642.9\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   642.9\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   642.9\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   642.9\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   642.9\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   642.9\n```\n\n\n:::\n:::\n\n\n\n-   위 언급과 같이 **baseR** 의 **\"/\"**보다 **collapse**의 **TRA function**을 이용하는 것이 더 빠르다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n\"/\"=      mtcars |> fgroup_by(cyl) |> fmutate(mpg_prop = mpg / fsum(mpg))      |> head(),     \n\"TRA=/\" = mtcars |> fgroup_by(cyl) |> fmutate(mpg_prop = fsum(mpg, TRA = \"/\")) |> head()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n  expr     min      lq     mean   median       uq     max neval cld\n     / 208.423 211.461 216.9684 212.9690 215.2815 456.075   100  a \n TRA=/ 198.332 200.922 203.9442 202.6085 204.8170 239.689   100   b\n```\n\n\n:::\n:::\n\n\n\n-   **fsum**은 grp 별로 연산을 처리하나, sum은 전체를 반영한다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> fgroup_by(cyl) |> fmutate(mpg_prop2 = fsum(mpg) / sum(mpg))|> head() #\"!=1\" \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_prop2\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 0.2149634\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 0.2149634\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 0.4562140\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 0.2149634\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 0.3288225\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 0.2149634\n```\n\n\n:::\n:::\n\n\n\n-   자유로운 **%>%** 의 사용\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 아래 둘은 동일하다.\n mtcars %>% fgroup_by(cyl) %>% ftransform(fselect(., hp:qsec) %>% fsum(TRA = \"/\")) %>% invisible()\n mtcars %>% fgroup_by(cyl) %>% fmutate(across(hp:qsec, fsum, TRA = \"/\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp         hp       drat         wt       qsec vs\nMazda RX4         21.0   6  160 0.12850467 0.15537849 0.12007333 0.13080102  0\nMazda RX4 Wag     21.0   6  160 0.12850467 0.15537849 0.13175985 0.13525111  0\nDatsun 710        22.8   4  108 0.10231023 0.08597588 0.09227220 0.08840435  1\nHornet 4 Drive    21.4   6  258 0.12850467 0.12270916 0.14734189 0.15448188  1\nHornet Sportabout 18.7   8  360 0.05974735 0.06967485 0.06144064 0.07248414  0\nValiant           18.1   6  225 0.12266355 0.10996016 0.15857012 0.16068023  1\n                  am gear carb\nMazda RX4          1    4    4\nMazda RX4 Wag      1    4    4\nDatsun 710         1    4    1\nHornet 4 Drive     0    3    1\nHornet Sportabout  0    3    2\nValiant            0    3    1\n```\n\n\n:::\n:::\n\n\n\n-   **set = TRUE**를 통해 원본 데이터에 반영할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n\n```{.r .cell-code}\n# mtcars의 열 hp:qsec의 값과 해당하는 g:cyl별 합의 비율.\nmtcars %>% fgroup_by(cyl) %>% fmutate(across(hp:qsec, fsum, TRA = \"/\", set = TRUE)) %>% invisible()\nhead(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp         hp       drat         wt       qsec vs\nMazda RX4         21.0   6  160 0.12850467 0.15537849 0.12007333 0.13080102  0\nMazda RX4 Wag     21.0   6  160 0.12850467 0.15537849 0.13175985 0.13525111  0\nDatsun 710        22.8   4  108 0.10231023 0.08597588 0.09227220 0.08840435  1\nHornet 4 Drive    21.4   6  258 0.12850467 0.12270916 0.14734189 0.15448188  1\nHornet Sportabout 18.7   8  360 0.05974735 0.06967485 0.06144064 0.07248414  0\nValiant           18.1   6  225 0.12266355 0.10996016 0.15857012 0.16068023  1\n                  am gear carb\nMazda RX4          1    4    4\nMazda RX4 Wag      1    4    4\nDatsun 710         1    4    1\nHornet 4 Drive     0    3    1\nHornet Sportabout  0    3    2\nValiant            0    3    1\n```\n\n\n:::\n:::\n\n\n\n-   **.apply = FALSE**를 통해 subset group에만 적용할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 각 g:cyl의 hp:qsec까지의 변수에 대한 부분 상관관계\nmtcars %>% fgroup_by(cyl) %>% fsummarise(across(hp:qsec, \\(x) qDF(pwcor(x), \"var\"), .apply = FALSE)) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cyl  var         hp       drat         wt       qsec\n1   4   hp  1.0000000 -0.4702200  0.1598761 -0.1783611\n2   4 drat -0.4702200  1.0000000 -0.4788681 -0.2833656\n3   4   wt  0.1598761 -0.4788681  1.0000000  0.6380214\n4   4 qsec -0.1783611 -0.2833656  0.6380214  1.0000000\n5   6   hp  1.0000000  0.2171636 -0.3062284 -0.6280148\n6   6 drat  0.2171636  1.0000000 -0.3546583 -0.6231083\n```\n\n\n:::\n:::\n\n\n\n## **이름/순번/vectors/정규표현식**으로 행/열을 지칭할 수 있다.\n\n```         \nget_vars(x, vars, return = \"names\", regex = FALSE, ...) \nget_vars(x, vars, regex = FALSE, ...) <- value \n\n- 위치도 선택가능하다.\nadd_vars(x, ..., pos = \"end\") \nadd_vars(x, pos = \"end\") <- value \n\n- data type을 지정할 수 있다. \nnum_vars(x, return = \"data\");   cat_vars(x, return = \"data\");   char_vars(x, return = \"data\"); \nfact_vars(x, return = \"data\");  logi_vars(x, return = \"data\");  date_vars(x, return = \"data\") \n\n- replace 또한 가능하다.\nnum_vars(x) <- value;   cat_vars(x) <- value;   char_vars(x) <- value; \nfact_vars(x) <- value;  logi_vars(x) <- value;  date_vars(x) <- value\n```\n\n## Efficient programming\n\n```         \n    > quick data conversion\n-   qDF(),  qDT(),  qTBL(),   qM(),   mrtl(),   mctl()\n    \n-   anyv(x, value) / allv(x, value)     # Faster than any/all(x == value)\n-   allNA(x)                            # Faster than all(is.na(x))\n-   whichv(x, value, invert = F)        # Faster than which(x (!/=)= value)\n-   whichNA(x, invert = FALSE)          # Faster than which((!)is.na(x))\n-   x %(!/=)=% value                    # Infix for whichv(v, value, TRUE/FALSE)\n-   setv(X, v, R, ...)                  # x\\[x(!/=)=v\\]\\<-r / x\\[v\\]\\<-r\\[v\\] (by reference)\n-   setop(X, op, V, rowwise = F)        # Faster than X \\<- X +/-/\\*// V (by reference)\n-   X %(+,-,\\*,/)=% V                   # Infix for setop,()\n-   na_rm(x)                            # Fast: if(anyNA(x)) x\\[!is.na(x)\\] else x,\n-   na_omit(X, cols = NULL, ...)        # Faster na.omit for matrices and data frames\n-   vlengths(X, use.names=TRUE)         # Faster version of lengths()\n-   frange(x, na.rm = TRUE)             # Much faster base::range\n-   fdim(X)                             # Faster dim for data frames\n```\n\n# Collapse and data.table\n\n**data.table**에서 **collapse**의 적용을 알아보자.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDT <- qDT(wlddev) # as.data.table(wlddev)\nDT %>% fgroup_by(country) %>% get_vars(9:13) %>% fmean()  #fgroup_by == gby\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   country      PCGDP   LIFEEX     GINI        ODA         POP\n                    <char>      <num>    <num>    <num>      <num>       <num>\n  1:           Afghanistan   483.8351 49.19717       NA 1487548499 18362258.22\n  2:               Albania  2819.2400 71.68027 31.41111  312928126  2708297.17\n  3:               Algeria  3532.2714 63.56290 34.36667  612238500 25305290.68\n  4:        American Samoa 10071.0659       NA       NA         NA    43115.10\n  5:               Andorra 40083.0911       NA       NA         NA    51547.35\n ---                                                                          \n212: Virgin Islands (U.S.) 35629.7336 73.71292       NA         NA    92238.53\n213:    West Bank and Gaza  2388.4348 71.60780 34.52500 1638581462  3312289.13\n214:           Yemen, Rep.  1069.6596 52.53707 35.46667  859950996 13741375.82\n215:                Zambia  1318.8627 51.09263 52.68889  734624330  8614972.38\n216:              Zimbabwe  1219.4360 54.53360 45.93333  397104997  9402160.33\n```\n\n\n:::\n\n```{.r .cell-code}\nDT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13] %>%  invisible()\ncollap(DT, ~ country, fmean, cols = 9:13) %>% invisible()     #same\n\nmicrobenchmark(collapse     = DT %>% gby(country) %>% get_vars(9:13) %>% fmean,\n               data.table   = DT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               data.table2  = DT[, lapply(.SD, fmean, na.rm = TRUE), keyby = country, .SDcols = 9:13])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n        expr      min        lq      mean    median        uq      max neval\n    collapse  339.330  369.4435  424.8557  397.9745  409.1075 3425.186   100\n  data.table 5010.470 5242.2960 5356.0409 5280.7165 5376.4760 8372.164   100\n data.table2 5164.241 5322.2865 5557.2280 5391.0230 5541.6530 8763.263   100\n cld\n a  \n  b \n   c\n```\n\n\n:::\n:::\n\n\n\n-   *DT\\[, lapply(.SD, fmean,...)\\]*가 *DT\\[, lapply(.SD, mean,...)\\]*보다 느린 것을 확인할 수 있다. \n    **data.table** 내에서 **mean**은 **baseR**의 **mean**이 아닌 **gmean**으로 **data.table**에 최적화되어있다. \n    반면, **lapply**와 함께 **fmean**을 사용하면 최적화된 방식으로 동작하지 않아 오히려 더 느리다.\n\n-   위 방식은 아래와 처리되는 방식이 유사하다. **fmean**을 모든 **group, columns**에 적용하기에 느리다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBY(gv(DT, 9:13), g, fmean) \n```\n:::\n\n\n\n이때, 아래와 같은 방법으로 이를 일정 수준 해결할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n fmean(gv(DT, 9:13), DT$country)\n g <- GRP(DT, \"country\"); add_vars(g[[\"groups\"]], fmean(gv(DT, 9:13), g))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDT <- qDT(wlddev); g <- GRP(DT, \"country\")\n#gv: abbreviation for get_vars()\nmicrobenchmark(a = fmean(gv(DT, 9:13), DT$country),\n               b0= g <- GRP(DT, \"country\"),\n               b = add_vars(g[[\"groups\"]], fmean(gv(DT, 9:13), g)),\n               dt_fmean = DT[, lapply(.SD, fmean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               dt_gmean = DT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13]) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n     expr      min        lq      mean    median       uq       max neval  cld\n        a  358.473  375.3265  392.0909  392.3025  398.751   580.505   100 a   \n       b0   76.707   92.1125  105.7192  110.7625  113.721   175.649   100  b  \n        b  224.185  238.6440  256.6076  255.7260  265.781   606.967   100 ab  \n dt_fmean 5213.289 5319.2375 5620.3223 5371.5520 5547.785 11522.735   100   c \n dt_gmean 5064.030 5246.1655 5389.5898 5315.4075 5475.593  8260.358   100    d\n```\n\n\n:::\n:::\n\n\n\n-   **dplyr**의 data %\\>% group_by(...) %\\>% summarize(...) 및 **data.table**의 \\[i, j, by\\] 구문은 \n    데이터 그룹에 함수를 적용하기 위한 보편적인 방식이다. 이는 다양한 함수를 그룹화된 데이터에\n    적용하며, 특히 **data.table**은 몇몇 내장 함수(**min, max, mean** 등)를 GForce; 내부적으로 최적화하여 처리한다.\n\n-   **collapse**는 데이터를 그룹화하여**(fgroup_by, collap)** 통계 및 변환 함수를 처리한다. (by C++)\n\n-   **collapse**의 모든 기능(BY는 예외)은 GForce 최적화가 되어 있지만, **data.table** 내에서 최적화 정도의 차이, \n    **lapply** 적용 상의 문제가 있는 것으로 추정된다.\n\n-   그렇다면 **fmean**을 **data.table**내에서 쓸 수는 없을까.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDT[, fmean(.SD, country), .SDcols = 9:13]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          PCGDP   LIFEEX     GINI        ODA         POP\n          <num>    <num>    <num>      <num>       <num>\n  1:   483.8351 49.19717       NA 1487548499 18362258.22\n  2:  2819.2400 71.68027 31.41111  312928126  2708297.17\n  3:  3532.2714 63.56290 34.36667  612238500 25305290.68\n  4: 10071.0659       NA       NA         NA    43115.10\n  5: 40083.0911       NA       NA         NA    51547.35\n ---                                                    \n212: 35629.7336 73.71292       NA         NA    92238.53\n213:  2388.4348 71.60780 34.52500 1638581462  3312289.13\n214:  1069.6596 52.53707 35.46667  859950996 13741375.82\n215:  1318.8627 51.09263 52.68889  734624330  8614972.38\n216:  1219.4360 54.53360 45.93333  397104997  9402160.33\n```\n\n\n:::\n\n```{.r .cell-code}\nDT[, fmean(gby(.SD, country)), .SDcols = c(1L, 9:13)] #gby = abbrviation for fgroup_by()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   country      PCGDP   LIFEEX     GINI        ODA         POP\n                    <char>      <num>    <num>    <num>      <num>       <num>\n  1:           Afghanistan   483.8351 49.19717       NA 1487548499 18362258.22\n  2:               Albania  2819.2400 71.68027 31.41111  312928126  2708297.17\n  3:               Algeria  3532.2714 63.56290 34.36667  612238500 25305290.68\n  4:        American Samoa 10071.0659       NA       NA         NA    43115.10\n  5:               Andorra 40083.0911       NA       NA         NA    51547.35\n ---                                                                          \n212: Virgin Islands (U.S.) 35629.7336 73.71292       NA         NA    92238.53\n213:    West Bank and Gaza  2388.4348 71.60780 34.52500 1638581462  3312289.13\n214:           Yemen, Rep.  1069.6596 52.53707 35.46667  859950996 13741375.82\n215:                Zambia  1318.8627 51.09263 52.68889  734624330  8614972.38\n216:              Zimbabwe  1219.4360 54.53360 45.93333  397104997  9402160.33\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(collapse        = DT %>% gby(country) %>% get_vars(9:13) %>% fmean,\n               data.table      = DT[, lapply(.SD, mean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               data.table_base = DT[, lapply(.SD, base::mean, na.rm = TRUE), keyby = country, .SDcols = 9:13],\n               hybrid_bad      = DT[, lapply(.SD, fmean), keyby = country, .SDcols = 9:13],\n               hybrid_ok       = DT[, fmean(gby(.SD, country)), .SDcols = c(1L, 9:13)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n            expr      min        lq      mean    median        uq      max\n        collapse  345.137  376.5125  419.4952  393.9470  399.4225 3603.978\n      data.table 5086.504 5240.5405 5384.2358 5319.8300 5484.4740 6284.893\n data.table_base 2545.283 2597.0910 2695.3421 2625.8495 2648.6360 6084.044\n      hybrid_bad 5197.406 5331.3155 5539.1046 5382.9660 5607.2690 8885.335\n       hybrid_ok  837.602  885.5560  899.4496  902.0515  914.6245 1003.834\n neval   cld\n   100 a    \n   100  b   \n   100   c  \n   100    d \n   100     e\n```\n\n\n:::\n:::\n\n\n\n-   **data.table**내에서 **fmean** 등을 같이 쓰는 것은 **바람직하지 않다.**\n\n```         \nDT %>% gby(country) %>% get_vars(9:13) %>% fmean\nfmean(gv(DT, 9:13), DT$country)\n```\n\n-   보다 효율적인 작업을 위해 위와 같이 **data.table** 외에서 처리하는 방식을 사용하자.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#fmean 이외의 예시: fsum\n\n# 국가별 ODA 합산 = 아래는 모두 동일. \nDT[, sum_ODA := sum(ODA, na.rm = TRUE), by = country]\nDT[, sum_ODA := fsum(ODA, country, TRA = \"replace_fill\")]  \nsettfm(DT, sum_ODA = fsum(ODA, country, TRA = \"replace_fill\"))  # settfm/tfm= settransform/ftransform \n\n# 여러 열을 변경할 때 settransform이 ':=' 보다 편리하다. \nsettfm(DT, perc_c_ODA = fsum(ODA, country, TRA = \"%\"),\n           perc_y_ODA = fsum(ODA, year, TRA = \"%\"))\n\nmicrobenchmark(\n  S1 = DT[, sum_ODA := sum(ODA, na.rm = TRUE), by = country],\n  S2 = DT[, sum_ODA := fsum(ODA, country, TRA = \"replace_fill\")],\n  S3 = settfm(DT, sum_ODA = fsum(ODA, country, TRA = \"replace_fill\"))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr      min        lq      mean    median       uq      max neval cld\n   S1 2088.236 2178.8360 2255.2440 2243.0780 2280.824 4270.312   100 a  \n   S2  409.735  484.6600  528.7572  533.0865  577.559  665.195   100  b \n   S3  121.994  171.2135  203.7296  202.9935  229.109  290.783   100   c\n```\n\n\n:::\n:::\n\n\n\n-   위와 같이 **data.table** 외에서 처리하는 방식을 사용하자.\n\n-   data.table에서 data 처리에 유용한 **collapse** 함수들:\n\n```         \n\"fcumsum()\"   \"fscale()\"    \"fbetween()\"    \"fwithin()\"   \"fhdbetween()\" \n\"fhdwithin()\"   \"flag()\"    \"fdiff()\"       \"fgrowth()\"\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Centering GDP\n#DT[, demean_PCGDP := PCGDP - mean(PCGDP, na.rm = TRUE), by = country]\nDT[, demean_PCGDP := fwithin(PCGDP, country)]\nsettfm(DT, demean_PCGDP = fwithin(PCGDP, country)) #settfm를 사용하자.\n\n# Lagging GDP\n#DT[order(year), lag_PCGDP := shift(PCGDP, 1L), by = country]\nDT[, lag_PCGDP := flag(PCGDP, 1L, country, year)]\n\n\n# Computing a growth rate\n#DT[order(year), growth_PCGDP := (PCGDP / shift(PCGDP, 1L) - 1) * 100, by = country]\nDT[, lag_PCGDP := fgrowth(PCGDP, 1L, 1L, country, year)] # 1 lag, 1 iteration\n\n# Several Growth rates\n#DT[order(year), paste0(\"growth_\", .c(PCGDP, LIFEEX, GINI, ODA)) := (.SD / shift(.SD, 1L) - 1) * 100, by = country, .SDcols = 9:13]\nDT %<>% tfm(gv(., 9:13) %>% fgrowth(1L, 1L, country, year) %>% add_stub(\"growth_\"))\nsettfmv(DT, 9:13, G, 1L, 1L, country, year, apply = FALSE)\n \nresult <- DT[sample(.N, 7)] |> fselect(9:ncol(DT)); print(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        PCGDP   LIFEEX  GINI        ODA      POP     sum_ODA perc_c_ODA\n        <num>    <num> <num>      <num>    <num>       <num>      <num>\n1:  7808.4047 71.04878    NA   65139999 42449038 26214490031  0.2484885\n2: 35593.4255 68.80683    NA         NA    56911          NA         NA\n3:  2171.3605 64.10800    NA 2025609985  2123180 73237229858  2.7658200\n4: 47413.6225 70.84878    NA         NA    56186          NA         NA\n5:   872.9171 55.17000    NA  350309998  6094259 18904160029  1.8530842\n6:  3131.2099 65.24600    NA   61150002   792736  4340079982  1.4089602\n7:  1814.4672 70.15500    NA  251289993 29774500  7412250079  3.3901985\n   perc_y_ODA demean_PCGDP lag_PCGDP growth_PCGDP growth_LIFEEX growth_GINI\n        <num>        <num>     <num>        <num>         <num>       <num>\n1:  0.1087501   -3117.1382  6.019063     6.019063    0.70872947          NA\n2:         NA    4307.9524  6.632324     6.632324    0.54279452          NA\n3:  3.6079552    -990.5459        NA           NA    0.95430065          NA\n4:         NA   16128.1494  4.547809     4.547809   -0.55800897          NA\n5:  0.5839065     -21.0514  1.094015     1.094015   -0.05977936          NA\n6:  0.1099883     120.4957 -3.230141    -3.230141    0.10893748          NA\n7:  0.2788049     419.3212  5.806588     5.806588    0.35045058          NA\n    growth_ODA growth_POP  G1.PCGDP   G1.LIFEEX G1.GINI      G1.ODA    G1.POP\n         <num>      <num>     <num>       <num>   <num>       <num>     <num>\n1: 1436.320823  0.9940010  6.019063  0.70872947      NA 1436.320823 0.9940010\n2:          NA  0.2572007  6.632324  0.54279452      NA          NA 0.2572007\n3:   12.181760  2.7719948        NA  0.95430065      NA   12.181760 2.7719948\n4:          NA  0.1283102  4.547809 -0.55800897      NA          NA 0.1283102\n5:    3.217532  3.1953119  1.094015 -0.05977936      NA    3.217532 3.1953119\n6:    2.652345  1.0645269 -3.230141  0.10893748      NA    2.652345 1.0645269\n7:   81.791218  1.4829887  5.806588  0.35045058      NA   81.791218 1.4829887\n```\n\n\n:::\n:::\n\n\n\n-   := 은 data.table내에서 최적화 정도가 낮아 collapse를 이용하는 것이 대부분의 경우 더 빠르다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  W1 = DT[, demean_PCGDP := PCGDP - mean(PCGDP, na.rm = TRUE), by = country],\n  W2 = DT[, demean_PCGDP := fwithin(PCGDP, country)],\n  L1 = DT[order(year), lag_PCGDP := shift(PCGDP, 1L), by = country],\n  L2 = DT[, lag_PCGDP := flag(PCGDP, 1L, country, year)],\n  L3 = DT[, lag_PCGDP := shift(PCGDP, 1L), by = country], # Not ordered\n  L4 = DT[, lag_PCGDP := flag(PCGDP, 1L, country)] # Not ordered\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n expr      min        lq      mean   median       uq       max neval    cld\n   W1 1912.389 1990.3745 2156.8241 2023.363 2085.882 11093.551   100 a     \n   W2  784.069  836.6985  873.2039  865.280  894.328  1336.105   100  b    \n   L1 4025.457 4216.2925 4483.2931 4281.839 4414.296 16599.366   100   c   \n   L2 1296.289 1338.7050 1467.9625 1373.009 1409.083  9663.483   100    d  \n   L3 2604.725 2672.9305 2748.6873 2697.509 2746.567  3559.639   100     e \n   L4  451.273  476.2480  515.3331  507.103  535.107   861.385   100      f\n```\n\n\n:::\n\n```{.r .cell-code}\n# flag와 같은 time series는 우선적으로 재정렬을 하지 않아 분명한 성능 차이가 존재한다. \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- qM(mtcars)\n# matrix to data: mrtl\nmrtl(m, names = T, return = \"data.table\") %>% head(2) # convert: data.table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive Hornet Sportabout Valiant\n       <num>         <num>      <num>          <num>             <num>   <num>\n1:        21            21       22.8           21.4              18.7    18.1\n2:         6             6        4.0            6.0               8.0     6.0\n   Duster 360 Merc 240D Merc 230 Merc 280 Merc 280C Merc 450SE Merc 450SL\n        <num>     <num>    <num>    <num>     <num>      <num>      <num>\n1:       14.3      24.4     22.8     19.2      17.8       16.4       17.3\n2:        8.0       4.0      4.0      6.0       6.0        8.0        8.0\n   Merc 450SLC Cadillac Fleetwood Lincoln Continental Chrysler Imperial\n         <num>              <num>               <num>             <num>\n1:        15.2               10.4                10.4              14.7\n2:         8.0                8.0                 8.0               8.0\n   Fiat 128 Honda Civic Toyota Corolla Toyota Corona Dodge Challenger\n      <num>       <num>          <num>         <num>            <num>\n1:     32.4        30.4           33.9          21.5             15.5\n2:      4.0         4.0            4.0           4.0              8.0\n   AMC Javelin Camaro Z28 Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa\n         <num>      <num>            <num>     <num>         <num>        <num>\n1:        15.2       13.3             19.2      27.3            26         30.4\n2:         8.0        8.0              8.0       4.0             4          4.0\n   Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E\n            <num>        <num>         <num>      <num>\n1:           15.8         19.7            15       21.4\n2:            8.0          6.0             8        4.0\n```\n\n\n:::\n:::\n\n\n\n-   fast linear model: **flm**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1) %>%  \n   fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, qDT(coeftest(lm(G(PCGDP) ~ G(LIFEEX))), \"Coef\"), keyby = country] %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <country>\n   country        Coef   Estimate Std. Error    t value    Pr(>|t|)\n    <char>      <char>      <num>      <num>      <num>       <num>\n1: Albania (Intercept) -3.6146411   2.371885 -1.5239527 0.136023086\n2: Albania   G(LIFEEX) 22.1596308   7.288971  3.0401591 0.004325856\n3: Algeria (Intercept)  0.5973329   1.740619  0.3431726 0.732731107\n4: Algeria   G(LIFEEX)  0.8412547   1.689221  0.4980134 0.620390703\n5:  Angola (Intercept) -3.3793976   1.540330 -2.1939445 0.034597175\n6:  Angola   G(LIFEEX)  4.2362895   1.402380  3.0207852 0.004553260\n```\n\n\n:::\n\n```{.r .cell-code}\n#절편과 변화율만 빠르게 알고싶다면 flm w/ mrtl: (no standard errors)\nwlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1L) %>% \n  fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, mrtl(flm(fgrowth(PCGDP)[-1L], \n               cbind(Intercept = 1, LIFEEX = fgrowth(LIFEEX)[-1L])), TRUE), keyby = country] %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <country>\n               country   Intercept     LIFEEX\n                <char>       <num>      <num>\n1:             Albania -3.61464113 22.1596308\n2:             Algeria  0.59733291  0.8412547\n3:              Angola -3.37939760  4.2362895\n4: Antigua and Barbuda -3.11880717 18.8700870\n5:           Argentina  1.14613567 -0.2896305\n6:             Armenia  0.08178344 11.5523992\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(\n  A= wlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1) %>%  \n   fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, qDT(coeftest(lm(G(PCGDP) ~ G(LIFEEX))), \"Coef\"), keyby = country] ,\n  \n  B= wlddev %>% fselect(country, PCGDP, LIFEEX) %>% na_omit(cols = -1L) %>% \n   fsubset(fnobs(PCGDP, country, \"replace_fill\") > 20L) %>% qDT %>% \n  .[, mrtl(flm(fgrowth(PCGDP)[-1L], \n               cbind(Intercept = 1, LIFEEX = fgrowth(LIFEEX)[-1L])), TRUE), keyby = country]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n expr        min        lq       mean     median         uq       max neval cld\n    A 167.429776 168.55069 172.656171 169.121475 172.448620 336.99646   100  a \n    B   7.141076   7.40031   7.818226   7.546154   7.698282  12.44983   100   b\n```\n\n\n:::\n\n```{.r .cell-code}\n# coeftest + lm + G 를 flm + fgrowth와 같은 collapse식으로 대체하여 큰 속도 이득을 볼 수 있다.\n```\n:::\n\n\n\n-   **collapse** w/ list; **rsplit; rapply2d; get_elem; unlist2d**\n\n\n\n\n\n\n\n**rapply2d()**: **data.table/frame**에 function 적용.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_summary_list <- DT_list %>% \n  rapply2d(lm, formula = G(PCGDP) ~ G(LIFEEX) + B(G(LIFEEX), country)) %>% \n  rapply2d(summary, classes = \"lm\")\n```\n:::\n\n\n\n**get_elem()**: 원하는 부분을 추출, 이후 **unlist2d**를 이용해 **data.table**로 만들 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n lm_summary_list %>%\n  get_elem(\"coefficients\") %>% \n  unlist2d(idcols = .c(Region, Income), row.names = \"Coef\", DT = TRUE) %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                Region              Income                  Coef  Estimate\n                <char>              <char>                <char>     <num>\n1: East Asia & Pacific         High income           (Intercept) 0.5313479\n2: East Asia & Pacific         High income             G(LIFEEX) 2.4935584\n3: East Asia & Pacific         High income B(G(LIFEEX), country) 3.8297123\n4: East Asia & Pacific Lower middle income           (Intercept) 1.3476602\n5: East Asia & Pacific Lower middle income             G(LIFEEX) 0.5238856\n6: East Asia & Pacific Lower middle income B(G(LIFEEX), country) 0.9494439\n   Std. Error   t value    Pr(>|t|)\n        <num>     <num>       <num>\n1:  0.7058550 0.7527720 0.451991327\n2:  0.7586943 3.2866443 0.001095466\n3:  1.6916770 2.2638554 0.024071386\n4:  0.7008556 1.9228785 0.055015131\n5:  0.7574904 0.6916069 0.489478164\n6:  1.2031228 0.7891496 0.430367103\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 물론, 이렇게도 할 수 있다. \nDT[, qDT(coeftest(lm(G(PCGDP) ~ G(LIFEEX) + B(G(LIFEEX), country))), \"Coef\"), \n   keyby = .(region, income)]\n```\n:::\n\n\n\n# Summary\n\n1.  **collapse**는 빠르며, data/memory 측면에서 경제적이다.\n\n2.  **vector, matrix, data.table** 등 데이터 형식에 구애받지 않고 사용가능하다.\n\n3.  (**dplyr, tidyverse, data.table** 등) 기존 **framework**와 통합하여 사용 가능하다.\n\n4.  **data.table**과 혼용하여 쓸 경우, **dt\\[\\]** 내부에서 사용하면 성능이 저하된다. \n    이는 내부적 데이터 처리 과정의 차이에서 기인한다.\n\n5.  **data.table** 형식을 처리할 때는, **아래**와 같은 문법으로 사용해야 이의 효과를 기대할 수 있다.\n\n```         \n권장되지 않음:\n>   DT[order(year), paste0(\"growth_\", .c(PCGDP, LIFEEX, GINI, ODA)) := (.SD / shift(.SD, 1L) - 1) * 100, \n          by = country, .SDcols = 9:13]\n권장됨\n>>    DT %<>% tfm(gv(., 9:13) %>% fgrowth(1L, 1L, country, year) %>% add_stub(\"growth_\"))\n>>    settfmv(DT, 9:13, G, 1L, 1L, country, year, apply = FALSE)\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}