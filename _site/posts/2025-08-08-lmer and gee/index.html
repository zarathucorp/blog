<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="author" content="Mingu Jee">
<meta name="dcterms.date" content="2025-08-12">
<meta name="description" content="lmer을 사용했을 때 추정치들의 standard error가 모두 같아지는 상황에 대해 알아봅시다.">
<title>반복측정자료 모델링: linear mixed effects model – 차라투 블로그</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/logo_favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-0626ff4d7a71b55c8707dcae1d04a9b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2fa66d5285053e3ebee39b9a5638a87d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-135478021-2', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script><style>html{ scroll-behavior: smooth; }</style>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script><link rel="stylesheet" href="../../styles.css">
</head>
<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner"><nav class="navbar navbar-expand-lg " data-bs-theme="dark"><div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../img/logo.png" alt="" class="navbar-logo"></a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">차라투 블로그</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
<li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://openstat.ai/" target="_blank"> 
<span class="menu-text">Applications</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-r-packages" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">R packages</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-r-packages">
<li>
    <a class="dropdown-item" href="https://jinseob2kim.github.io/jstable/" target="_blank">
 <span class="dropdown-text">jstable</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://jinseob2kim.github.io/jskm/" target="_blank">
 <span class="dropdown-text">jskm</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://jinseob2kim.github.io/jsmodule/" target="_blank">
 <span class="dropdown-text">jsmodule</span></a>
  </li>  
    </ul>
</li>
  <li class="nav-item">
    <a class="nav-link" href="../../contributors.html"> 
<span class="menu-text">Contributors</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-partners" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Partners</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-partners">
<li>
    <a class="dropdown-item" href="https://www.r-bloggers.com/" target="_blank">
 <span class="dropdown-text"><img src="https://www.r-bloggers.com/favicon.ico"> R-bloggers</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/shinykorea/" target="_blank">
 <span class="dropdown-text"><img width="16px" src="https://avatars.githubusercontent.com/u/46996346?s=200&amp;v=4"> Shinykorea</span></a>
  </li>  
    </ul>
</li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/zarathucorp" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/company/zarathu/" target="_blank"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" target="_blank"> <i class="bi bi-rss" role="img" aria-label="RSS">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-bi-translate" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-translate" role="img">
</i> 
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-bi-translate">
<li>
    <a class="dropdown-item" href="../../../index.html">
 <span class="dropdown-text">한국어</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../en/index.html">
 <span class="dropdown-text">English</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../jp/index.html">
 <span class="dropdown-text">日本語</span></a>
  </li>  
    </ul>
</li>
</ul>
</div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav></header><!-- content --><header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full"><div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">반복측정자료 모델링: linear mixed effects model</h1>
                  <div>
        <div class="description">
          <p>lmer을 사용했을 때 추정치들의 standard error가 모두 같아지는 상황에 대해 알아봅시다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">R</div>
                <div class="quarto-category">rpackage</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p><a href="https://github.com/Rafa-M-J">Mingu Jee</a> <a href="mailto:rafamingujee047@gmail.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 12, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">On this page</h2>
   
  <ul>
<li><a href="#%EA%B0%9C%EC%9A%94" id="toc-개요" class="nav-link active" data-scroll-target="#%EA%B0%9C%EC%9A%94">개요</a></li>
  <li><a href="#%EB%B0%98%EB%B3%B5%EC%B8%A1%EC%A0%95%EC%9E%90%EB%A3%8C" id="toc-반복측정자료" class="nav-link" data-scroll-target="#%EB%B0%98%EB%B3%B5%EC%B8%A1%EC%A0%95%EC%9E%90%EB%A3%8C">1. 반복측정자료</a></li>
  <li>
<a href="#fixed-random-effects" id="toc-fixed-random-effects" class="nav-link" data-scroll-target="#fixed-random-effects">2. Fixed &amp; Random Effects</a>
  <ul class="collapse">
<li><a href="#fixed-effects" id="toc-fixed-effects" class="nav-link" data-scroll-target="#fixed-effects">Fixed Effects</a></li>
  <li><a href="#random-effects" id="toc-random-effects" class="nav-link" data-scroll-target="#random-effects">Random Effects</a></li>
  </ul>
</li>
  <li>
<a href="#linear-mixed-effect-model-with-random-intercept" id="toc-linear-mixed-effect-model-with-random-intercept" class="nav-link" data-scroll-target="#linear-mixed-effect-model-with-random-intercept">3. Linear Mixed Effect Model with Random Intercept</a>
  <ul class="collapse">
<li><a href="#linear-regression-model" id="toc-linear-regression-model" class="nav-link" data-scroll-target="#linear-regression-model">Linear Regression Model</a></li>
  <li><a href="#linear-mixed-model" id="toc-linear-mixed-model" class="nav-link" data-scroll-target="#linear-mixed-model">Linear Mixed Model</a></li>
  <li><a href="#why-linear-mixed-model-is-better" id="toc-why-linear-mixed-model-is-better" class="nav-link" data-scroll-target="#why-linear-mixed-model-is-better">Why Linear Mixed Model Is Better?</a></li>
  </ul>
</li>
  <li>
<a href="#gee-vs-lmer" id="toc-gee-vs-lmer" class="nav-link" data-scroll-target="#gee-vs-lmer">4. GEE VS lmer</a>
  <ul class="collapse">
<li><a href="#gee" id="toc-gee" class="nav-link" data-scroll-target="#gee">GEE</a></li>
  <li><a href="#blue-vs-blup" id="toc-blue-vs-blup" class="nav-link" data-scroll-target="#blue-vs-blup">BLUE vs BLUP</a></li>
  </ul>
</li>
  <li><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0" id="toc-마치며" class="nav-link" data-scroll-target="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
  </ul></nav>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content"><!-- Google tag (gtag.js) --><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-L0DYYSH9KM"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-L0DYYSH9KM');
</script><section id="개요" class="level1"><h1>개요</h1>
<p>linear mixed model에서 intercept에만 random effect를 주었을 때 추정치들의 standard error가 같아지는 경우에 대해 알아봅시다.</p>
<hr></section><section id="반복측정자료" class="level1"><h1>1. 반복측정자료</h1>
<p>어떤 임상실험에서 연구자가 특정 기간을 주기로 당뇨병 환자들의 인슐린 농도를 측정한다고 해봅시다. 이러한 경우 환자 각각은 서로 다른 사람이므로, <strong>서로 다른 환자에게서 관찰된 데이터</strong>는 서로 <strong>독립</strong>이라고 봐도 무방합니다.</p>
<p>그러나 <strong>동일한 환자에게서 반복적으로 측정된 값</strong>들은 서로 독립이라고 보기 어렵습니다. 동일한 환자에게서 측정정되었기 때문에, 각 시점의 데이터들 간에는 특정한 <strong>상관관계가 존재</strong>할 것이라는 생각을 해볼 수 있겠습니다. 예컨대, 당뇨임에도 치료 효과가 좋은 환자는 시간이 지날수록 인슐린 농도가 점점 높아질 수 있고, 치료에 소극적인 환자의 경우에는 반대의 경향성을 보일 것입니다.</p>
<p>일반적으로 회귀분석에서는 모든 관측지(y, 종속변수)들이 서로 <strong>독립</strong>이라고 가정합니다. 그러나 반복측정자료의 경우 위와 같은 이유 때문에 회귀분석을 통해 분석하기에 어려움이 존재합니다. 이에 따라 반복측정자료를 분석하는 통계적인 방법론으로는 <strong>Mixed Effect Model</strong>을 사용하는 방법과, <strong>Generalized Estimating Equations</strong>을 이용하는 방법 등이 존재합니다. 우선 Mixed Effect Model 중 <strong>Linear Mixed Effect Model</strong>에 대해 알아보도록 하겠습니다.</p>
</section><section id="fixed-random-effects" class="level1"><h1>2. Fixed &amp; Random Effects</h1>
<p>모델에 대해 본격적으로 살펴보기 전에, <strong>fixed effects</strong>와 <strong>random effects</strong>에 대해 간단하게 알아보겠습니다.</p>
<section id="fixed-effects" class="level2"><h2 class="anchored" data-anchor-id="fixed-effects">Fixed Effects</h2>
<p>우선 <strong>fixed effects</strong>의 경우, 우리가 관심 있는 <strong>전체 모집단의 평균적인 효과를 추정하는 모수</strong>입니다. 예를 들어, 다음과 같은 모델에 대해 생각해보겠습니다.</p>
<p><span class="math inline">\(y_{ij} = \beta_0 + \beta_1 * Group_i + \beta_2 * Time_{ij} + \beta_3(Group_i * Time_{ij}) + \epsilon_{ij}\)</span></p>
<p><span class="math inline">\(y_{ij}\)</span>는 i번째 환자의 j번째 측정값을 의미하고, <span class="math inline">\(\epsilon_{ij}\sim N(0, \sigma^2)\)</span>라고 가정하겠습니다.</p>
<p>위 모델에서</p>
<p><span class="math inline">\(\beta_1\)</span>(<strong>Group effect</strong>): 시간에 관계없이 group간 평균적인 차이를 나타냅니다. 이는 baseline에서 그룹 간 평균 차이를 의미합니다.</p>
<p><span class="math inline">\(\beta_2\)</span>(<strong>Time effect</strong>): 어떤 Group에 속하는지와 무관하게 시간이 지남에 따라 전체 평균이 얼마나 변하는지를 나타냅니다. 이 값이 음수라면 평균이 감소, 양수면 평균이 증가하는 경향성을 의미합니다.</p>
<p><span class="math inline">\(\beta_3\)</span>(<strong>Interaction effect</strong>): 시간과 그룹 간의 상호작용 효과로, 시간에 따른 치료 효과의 변화 차이를 나타냅니다. 즉, 시간에 따라 치료효과가 Group 별로 얼마나 다르게 나타났는지를 의미합니다.</p>
<p>fixed effects의 경우 위와 같이 estimate 형태로 도출되고, 전체 데이터에 일관되게 적용됩니다.</p>
</section><section id="random-effects" class="level2"><h2 class="anchored" data-anchor-id="random-effects">Random Effects</h2>
<p><strong>random effects</strong>의 경우 fixed effects와 비슷하면서도 조금 다른 형태를 보입니다. 이번 포스팅에서는 <strong>intercept</strong>에만 random effect를 주어 여기에 집중해보도록 하겠습니다.</p>
<p>random effects는 이름 그대로 무작위적인 부분 즉, <strong>확률적인 효과</strong>를 모델링 합니다. 앞서 언급했듯 fixed effects가 우리가 관심 있는 모집단 전체의 평균적인 효과를 추정하는 모수였다면, random effects는 그 <strong>모집단에서 추출된 개별 sample이나 cluster가 갖는 특징이나 변동성</strong>을 잡아내는 <strong>확률변수(random variable)</strong>입니다.</p>
<p>앞서 언급한 당뇨병 환자들을 대상으로 한 임상실험을 다시 생각해봅시다. 모든 환자들이 동일한 치료를 받더라도, 치료 효과가 나타나는 시작점이나(baseline)이나 시간에 따른 변화 정도는 환자 개개인마다 다를 수 있습니다. 이러한 <strong>이질성(heterogeneity)</strong>을 설명해주는 것이 <strong>random effects</strong>입니다. 즉, 각 subject가 전체적인 평균(<span class="math inline">\(\beta_0\)</span>)으로부터 얼마나 벗어나 있는지를 나타내는 <strong>확률변수</strong>로 활용됩니다. 아래 모델을 보겠습니다.</p>
<p><span class="math inline">\(y_{ij} = (u_{i} +\beta_0) + \beta_1 * Group_i + \beta_2 * Time_{ij} + \beta_3(Group_i * Time_{ij}) + \epsilon_{ij}\)</span></p>
<p>여기서 새로 추가된 <span class="math inline">\(u_i\)</span>가 바로 i번째 환자의 random effect입니다. 이는 특정 상수가 아니라 <span class="math inline">\(u_i \sim N(0, \sigma_u^2)\)</span>을 따르는 확률변수이며, 모든 <span class="math inline">\(i, j\)</span>에 대해 <span class="math inline">\(\epsilon_{ij}\)</span>과 독립이라고 가정합니다.</p>
<p>위 모델은 결국 다음을 가정합니다.</p>
<ol type="1">
<li><p>모든 환자들은 평균적인 시작점을 공유하지만, 각 환자는 자신만의 고유한 시작점(intercept)을 (<span class="math inline">\(u_i +\beta_0\)</span>) 갖습니다(<strong>random effects</strong>).</p></li>
<li><p>Group, Time, Interaction effects는 모든 환자에게 동일하하게 적용됩니다(<strong>fixed effects</strong>).</p></li>
</ol>
<p>이처럼 모델에 random effects를 포함하게 되면, 단순하게 모든 환자의 평균적인 경향성만을 보는 것에서 한 발 더 나아가, 환자들 사이에 존재하는 변동까지 고려하게 되어 데이터를 훨씬 더 정교하게 설명할 수 있습니다.</p>
<p>결국 random effects가 표현하고자 하는 것은 <strong>‘변동’</strong>에 초점을 맞추기에, fixed effects는 <strong>기댓값</strong>에 해당하는 <span class="math inline">\(E[y_{ij}]\)</span>를 모델링 한다면, random effects는 <strong>분산(공분산)</strong>에 해당하는 <span class="math inline">\(Var(y_{ij})\)</span>를 모델링 합니다.</p>
<p>실제로 이 모델을 통해 i번째 환자의 첫번째와 두번째 시점의 공분산을 구해보면, <span class="math inline">\(Cov(y_{i1},y_{i2}) = Cov(u_i+\epsilon_{i1}, u_i+\epsilon_{i2})\)</span> <span class="math inline">\(= Cov(u_i,u_i) + Cov(u_i,\epsilon_{i1}) + Cov(u_i,\epsilon_{i2}) + Cov(\epsilon_{i1}, \epsilon_{i2})\)</span> <span class="math inline">\(= \sigma_u^2\)</span>으로 도출되므로, 같은 환자에게서 다른 시간대에 측정된 정보는 상관되어 있음을 확인할 수 있습니다.</p>
<hr></section></section><section id="linear-mixed-effect-model-with-random-intercept" class="level1"><h1>3. Linear Mixed Effect Model with Random Intercept</h1>
<p>자 이제 intercept에만 random effects가 주어진 상태에서 어떤 경우에 standard error가 같아지는지 알아보겠습니다. 이를 만족하기 위해서는 다음과 같은 엄격한 조건이 모두 성립해야합니다.</p>
<ol type="1">
<li><p><strong>Complete Case</strong>: 주어진 데이터에서 <strong>결측이 단 하나라도 존재해서는 안 됩니다</strong>.</p></li>
<li><p><strong>Balanced Data</strong>: <strong>연구 디자인이 완벽하게 대칭적이고 균형 잡혀있어야</strong> 합니다. 반복측정자료에서 <strong>균형</strong>의 의미는 크게 두 가지를 의미합니다. 첫째는 <strong>관측 횟수의 균형</strong>으로 <strong>모든 환자가 동일한 횟수로 측정</strong>되어야하며, 둘째는 <strong>관측 시점의 균형</strong>으로, <strong>모든 환자가 동일한 시점에 측정</strong>되어야 합니다.</p></li>
<li><p><strong>Compound Symmtery</strong>: <strong>모든 반복측정자료들 사이의 상관관계가 동일</strong>해야 합니다. 즉, 모든 측정 시점에서 각 데이터의 분산은 동일해야 하고<span class="math inline">\((\forall i, j,\  Var(Y_{ij}) = \sigma^2 + {\sigma_u}^2)\)</span>, 각 환자 내에서 임의의 두 시점간 공분산 또한 항상 동일해야 합니다<span class="math inline">\((Cov(Y_{ij}, Y_{ik})= {\sigma_u}^2 \text{, where } j\neq k)\)</span>.</p></li>
</ol>
<p>예시 데이터를 확인해보겠습니다. 참고로 예시 데이터의 값들은 모두 임의로 채워넣었기에 결과가 유의하고 않고는 의미가 없음을 미리 말씀드립니다.</p>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://ycphs.github.io/openxlsx/index.html">openxlsx</a></span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu">openxlsx</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/openxlsx/man/read.xlsx.html">read.xlsx</a></span><span class="op">(</span><span class="st">"data.xlsx"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 80  4</code></pre>
</div>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">data</span>,<span class="fl">10</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   NO          Time Group     Value
1   1        Pre OP 65-79 14.786093
2   1  Post 1 month 65-79 10.477890
3   1 Post 6 months 65-79 10.196241
4   1   Post 1 year 65-79  7.049579
5   2        Pre OP 65-79  9.057036
6   2  Post 1 month 65-79 10.267466
7   2 Post 6 months 65-79  9.657085
8   2   Post 1 year 65-79 10.387103
9   3        Pre OP 65-79  8.508681
10  3  Post 1 month 65-79 10.999663</code></pre>
</div>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">data</span>,<span class="fl">10</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   NO          Time Group     Value
71 18 Post 6 months   ≥80  6.702226
72 18   Post 1 year   ≥80 10.030724
73 19        Pre OP   ≥80  9.320332
74 19  Post 1 month   ≥80  9.939527
75 19 Post 6 months   ≥80 10.699433
76 19   Post 1 year   ≥80 10.021359
77 20        Pre OP   ≥80  8.859701
78 20  Post 1 month   ≥80  9.440627
79 20 Post 6 months   ≥80 10.545564
80 20   Post 1 year   ≥80  8.391252</code></pre>
</div>
</div>
<p>이 데이터는 총 20명의 환자를 각 4번씩 반복측정한 데이터입니다. NO열은 각 환자의 ID를 의미하고, Time은 총 4개로 수술 직후, 1개월 후, 6개월 후, 1년 후로 나뉘어 있습니다. Group의 경우 65~79세인 경우(NO가 1-10인 환자)와 80세 이상(NO가 11-20인 환자)인 두 가지 경우가 존재합니다. 이 데이터는 결측이 하나도 존재하지 않고 20명의 환자에 대해 각각 모두 같은 시점에 같은 횟수가 측정된 <strong>Complete &amp; Balanced data</strong>입니다. 우리는 이러한 반복측정자료에서 Time과 Group에 대한 정보로 Value값에 대해 예측하고 싶어하는 상황입니다. Compounds Symmetry만 만족한다면, 앞서 말했던 것처럼 모든 S.E. 값이 동일하게 나올 것입니다. 한 번 확인해보겠습니다.</p>
<p>lme4패키지의 lmer 함수를 사용하여 진행해보면 아래와 같은 결과를 얻을 수 있습니다.</p>
<div class="cell">
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/lme4/lme4/">lme4</a></span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: Matrix</code></pre>
</div>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lmer_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/lme4/man/lmer.html">lmer</a></span><span class="op">(</span></span>
<span>  <span class="va">Value</span> <span class="op">~</span> <span class="va">Group</span><span class="op">*</span><span class="va">Time</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span><span class="op">|</span><span class="va">NO</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">lmer_fit</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Linear mixed model fit by REML ['lmerMod']
Formula: Value ~ Group * Time + (1 | NO)
   Data: data

REML criterion at convergence: 310.5

Scaled residuals: 
    Min      1Q  Median      3Q     Max 
-3.2756 -0.4501  0.0719  0.4712  2.6606 

Random effects:
 Groups   Name        Variance Std.Dev.
 NO       (Intercept) 0.04915  0.2217  
 Residual             3.33376  1.8259  
Number of obs: 80, groups:  NO, 20

Fixed effects:
                             Estimate Std. Error t value
(Intercept)                    9.9769     0.5816  17.153
Group65-79                     0.2331     0.8225   0.283
TimePost 1 year               -0.4466     0.8165  -0.547
TimePost 6 months              0.4467     0.8165   0.547
TimePre OP                    -0.9778     0.8165  -1.197
Group65-79:TimePost 1 year     0.2448     1.1548   0.212
Group65-79:TimePost 6 months  -0.1802     1.1548  -0.156
Group65-79:TimePre OP          0.7250     1.1548   0.628

Correlation of Fixed Effects:
            (Intr) G65-79 TmPs1y TmPs6m TmPrOP G65-1y G65-6m
Group65-79  -0.707                                          
TimePost1yr -0.702  0.496                                   
TmPst6mnths -0.702  0.496  0.500                            
TimePre OP  -0.702  0.496  0.500  0.500                     
G65-79:TP1y  0.496 -0.702 -0.707 -0.354 -0.354              
G65-79:TP6m  0.496 -0.702 -0.354 -0.707 -0.354  0.500       
G65-79:TPOP  0.496 -0.702 -0.354 -0.354 -0.707  0.500  0.500</code></pre>
</div>
</div>
<p>summary의 Random effects를 보면 intercept에 대해서만 적용된 모습을 확인할 수 있습니다. Fixed effects의 Std.Error을 보게 되면 time effect와 interaction effect에 해당하는 부분의 <strong>Std. Error가 모두 같은 모습</strong>을 확인할 수 있습니다. 어째서 이런 결과가 나타나는 것일까요?</p>
<section id="linear-regression-model" class="level2"><h2 class="anchored" data-anchor-id="linear-regression-model">Linear Regression Model</h2>
<p>일반적인 선형 회귀 모델을 행렬 형태로 표현하면 다음과 같이 나타낼 수 있습니다.</p>
<p><span class="math inline">\(Y = X\beta + \epsilon\)</span></p>
<p>여기서 <span class="math inline">\(\epsilon \overset{\mathrm{iid}}{\sim} N(0, \sigma^2I)\)</span>이라고 가정하는 것이 일반적입니다. 이후 최소제곱법(LSE)를 사용하여 <span class="math inline">\(\hat\beta=(X^TX)^{-1}X^TY\)</span>라는 추정량을 얻을 수 있고, <span class="math inline">\(Var(\hat\beta)=\sigma^2(X^TX^{-1})\)</span>라고 계산할 수 있습니다.</p>
</section><section id="linear-mixed-model" class="level2"><h2 class="anchored" data-anchor-id="linear-mixed-model">Linear Mixed Model</h2>
<p>지금 우리가 다루고 있는 모델은 여기에 상관관계를 위해 <span class="math inline">\(u\)</span>라는 term을 추가한 linear mixed model이고, 오차의 독립성 가정을 하지 않기에 선형 회귀 모델과는 조금 다른 구조와 분산-공분산 행렬을 가집니다. 이를 아래와 같이 표현할 수 있습니다.</p>
<p><span class="math inline">\(Y = X\beta+Zu+ \epsilon\)</span></p>
<p><span class="math inline">\(u \overset{\mathrm{iid}}{\sim} N(0, \sigma_u^2I), \ \epsilon \overset{\mathrm{iid}}{\sim} N(0, \sigma^2I)\)</span>이고, 이 둘은 독립이라고 가정하겠습니다.</p>
<p>i번째 환자 데이터의 분산-공분산 구조를 살펴보면 다음과 같습니다. <span class="math display">\[
Var(Y_i) = V_i = Var(X_i\beta+Z_iu_i+\epsilon_i)
\]</span> <span class="math display">\[
= Var(Z_iu_i+\epsilon_i)
\]</span> <span class="math display">\[
= Var(Z_iu_i) + Var(\epsilon_i) (\because \epsilon \perp\!\!\!\perp u)
\]</span> <span class="math display">\[
= Z_iVar(u_i)Z_i^T + Var(\epsilon_i)
\]</span></p>
<p>총 20명의 환자가 4번씩 반복측정한 상황이고, random effects가 intercept term에만 존재하기에 <span class="math inline">\(u_i\)</span>는 univariate normal distribution을 따르는 확률변수가 되고, <span class="math display">\[Z_i = \begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix} \]</span> 라고 할 수 있으므로 <span class="math display">\[
V_i = \begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
\sigma_u^2
\begin{bmatrix}
1 \\ 1 \\ 1 \\ 1
\end{bmatrix} +
\sigma^2
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
= \begin{bmatrix}
\sigma^2+\sigma_u^2 &amp; \sigma_u^2 &amp; \sigma_u^2 &amp; \sigma_u^2 \\
\sigma_u^2 &amp; \sigma^2+\sigma_u^2 &amp; \sigma_u^2 &amp; \sigma_u^2 \\
\sigma_u^2 &amp; \sigma_u^2 &amp; \sigma^2+\sigma_u^2 &amp; \sigma_u^2 \\
\sigma_u^2 &amp; \sigma_u^2 &amp; \sigma_u^2 &amp; \sigma^2+\sigma_u^2
\end{bmatrix}
\]</span> 라는 결과를 얻게 됩니다. 이를 통해 random intercept 모델은 <strong>compound symmetry</strong> 구조를 만족함을 확인할 수 있습니다.</p>
<p>자 그럼 이제 <span class="math inline">\(\beta\)</span>의 추정치를 구해보겠습니다. 일반적인 Linear Regression Model에서 OLS(Ordinary Least Square)방법을 이용해 <span class="math inline">\(\hat\beta=(X^TX)^{-1}X^TY\)</span>를 도출할 수 있다고 했고, 대략적인 과정은 다음과 같습니다.</p>
<p><span class="math display">\[
Y = X\beta + \epsilon
\]</span></p>
<p><span class="math display">\[
\text{Let }
Q(\beta) = (Y - X\beta)^T(Y-X\beta)
= Y^TY -2Y^TX\beta +\beta X^TX \beta
\]</span> <span class="math display">\[
\text{Then } \arg\min_\beta Q(\beta)=\hat\beta \text{ would be the vector that satisfies } \frac{\partial Q(\beta)}{\partial \beta} = 0
\]</span></p>
<p><span class="math display">\[
\text{since }Q(\beta) \text{ is a convex function w.r.t } \beta.
\]</span></p>
<p><span class="math display">\[
\text{We know that }X^TX \text{ is symmetric and by assuming it's invertible,}
\]</span></p>
<p><span class="math display">\[
\frac{\partial Q(\beta)}{\partial \beta} = -2X^TY + 2X^TX\beta = 0
\]</span> <span class="math display">\[
X^TX\beta = X^TY
\]</span></p>
<p><span class="math display">\[
\therefore \hat\beta = (X^TX)^{-1}X^TY
\]</span> 자 이제는 이 방법을 살짝 비틀어서 Linear Mixed Model의 경우를 살펴보겠습니다. 일반적인 형태의 모델은 다음과 같았습니다.</p>
<p><span class="math display">\[
Y = X\beta+Zu+ \epsilon
\]</span></p>
<p><span class="math display">\[
\text{Let } Zu+\epsilon = \epsilon^*
\]</span> <span class="math display">\[
\text{Then }Y = X\beta + \epsilon^*
\]</span> <span class="math inline">\(Var(Y) = V\)</span>는 <strong>symmertic &amp; positive-semi-definite matrix</strong>이므로 <strong>Cholesky Decomposition</strong>에 의해 다음을 만족하는 가역인 행렬 <span class="math inline">\(\Sigma\)</span>가 존재합니다. <span class="math inline">\(V = \Sigma \Sigma^T\)</span>. 이제 <span class="math inline">\(\Sigma^{-1}\)</span>을 위 모델의 양변에 곱해봅시다. <span class="math display">\[
\Sigma^{-1} Y = \Sigma^{-1}X\beta + \Sigma^{-1}\epsilon^*
\]</span> 이제 아래와 같이 변수들을 새로 정의하면, <span class="math display">\[
\Sigma^{-1} Y = \tilde Y,
\]</span> <span class="math display">\[
\Sigma^{-1}X\beta = \tilde X\beta
\]</span></p>
<p><span class="math display">\[
\Sigma^{-1}\epsilon^* = \tilde \epsilon
\]</span></p>
<p>아래와 같이 OLS의 경우와 아주 유사한 형태의 모델을 새로 정의할 수 있습니다. <span class="math display">\[
\tilde Y = \tilde X\beta + \tilde \epsilon
\]</span> 이러한 방법을 OLS를 일반화했다고 하여 <strong>Generalized Least Square(GLS)</strong>라고 부릅니다. 이제 OLS와 형태가 같기 때문에 <span class="math inline">\(\hat\beta\)</span>의 추정량은 다음와 같이 도출됩니다.</p>
<p><span class="math display">\[
\hat\beta_{GLS} = (\tilde X^T\tilde X)^{-1}\tilde X^T\tilde Y
\]</span></p>
<p><span class="math display">\[
= ((\Sigma^{-1}X)^T\Sigma^{-1}X)^{-1}(\Sigma^{-1}X)^T \Sigma^{-1}Y
\]</span></p>
<p><span class="math display">\[
= (X^T{\Sigma^T}^{-1}\Sigma^{-1}X)^{-1}X^T{\Sigma^T}^{-1}\Sigma^{-1}Y
\]</span></p>
<p><span class="math display">\[
= (X^T(\Sigma^T\Sigma)^{-1}X)^{-1}X^T(\Sigma^T\Sigma)^{-1}Y
\]</span></p>
<p><span class="math display">\[
= (X^T(\Sigma\Sigma^T)^{-1}X)^{-1}X^T(\Sigma\Sigma^T)^{-1}Y \ (\because \Sigma^T =\Sigma)
\]</span></p>
<p><span class="math display">\[
= (X^TV^{-1}X)^{-1}X^TV^{-1}Y
\]</span> 임을 알 수 있습니다. 그렇다면 분산-공분산 행렬은 다음과 같이 유도될 것입니다.</p>
<p><span class="math display">\[
Var(\hat\beta_{GLS}) = Var((X^TV^{-1}X)^{-1}X^TV^{-1}Y)
\]</span></p>
<p><span class="math display">\[
= (X^TV^{-1}X)^{-1}X^TV^{-1} Var(Y) ((X^TV^{-1}X)^{-1}X^TV^{-1})^T
\]</span></p>
<p><span class="math display">\[
(X^TV^{-1}X)^{-1}X^TV^{-1}V {V^{-1}}^TX {(X^TV^{-1}X)^{T}}^{-1}
\]</span></p>
<p><span class="math display">\[
(X^TV^{-1}X)^{-1}(X^TV^{-1}X) (X^TV^{-1}X)^{-1} \ (\because VV^{-1}= I, {V^{-1}}^T=V^T)
\]</span></p>
<p><span class="math display">\[
= (X^TV^{-1}X)^{-1}
\]</span> 앞에서 보인것 처럼 <span class="math inline">\(V\)</span>는 <strong>Compound Symmertry</strong> 구조이고, <strong>Complete &amp; Balanced</strong>한 데이터를 다루고 있기에 Design matrix인 X의 구조도 변하지 않습니다. 결국 standard error을 결정짓는 것은 방금 전 구한 <span class="math inline">\(Var(\hat\beta_{GLS})\)</span>의 대각성분과 관련이 있을텐데, 이 값이 같기 때문에 fixed effects의 standard error가 같게 나오는 것입니다.</p>
</section><section id="why-linear-mixed-model-is-better" class="level2"><h2 class="anchored" data-anchor-id="why-linear-mixed-model-is-better">Why Linear Mixed Model Is Better?</h2>
<p>지금까지 잘 읽어오시다가 몇몇 분들은 이런 생각이 드셨을 수도 있습니다.</p>
<p><em>반복측정자료고 뭐고 그냥 환자 NO를 dummy variable로 만들어서 fitting해도 되지 않나? 굳이 왜 random effects를 쓰지? 이렇게 하면 fixed effects만으로도 표현이 가능한데…</em></p>
<p>네 맞습니다. 가능합니다. 한 번 그렇게 진행해볼까요?</p>
<div class="cell">
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">glm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span><span class="op">(</span></span>
<span>  <span class="va">Value</span> <span class="op">~</span> <span class="va">NO</span> <span class="op">+</span> <span class="va">Group</span> <span class="op">+</span> <span class="va">Time</span> <span class="op">+</span> <span class="va">Group</span><span class="op">*</span><span class="va">Time</span>,</span>
<span>  data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">glm_fit</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = Value ~ NO + Group + Time + Group * Time, data = data)

Coefficients: (1 not defined because of singularities)
                             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)                  10.67448    1.04090  10.255 2.78e-14 ***
NO10                          0.43968    1.29108   0.341   0.7348    
NO11                         -0.24069    1.47206  -0.164   0.8707    
NO12                         -0.88679    1.47206  -0.602   0.5494    
NO13                          0.48099    1.47206   0.327   0.7451    
NO14                         -0.71105    1.47206  -0.483   0.6310    
NO15                          0.28560    1.47206   0.194   0.8469    
NO16                         -2.18372    1.47206  -1.483   0.1438    
NO17                          0.75654    1.47206   0.514   0.6094    
NO18                         -2.92089    1.47206  -1.984   0.0523 .  
NO19                         -0.43488    1.47206  -0.295   0.7688    
NO2                          -0.78528    1.29108  -0.608   0.5456    
NO20                         -1.12076    1.47206  -0.761   0.4498    
NO3                          -0.50924    1.29108  -0.394   0.6948    
NO4                          -1.20306    1.29108  -0.932   0.3556    
NO5                          -0.20593    1.29108  -0.160   0.8739    
NO6                          -1.05182    1.29108  -0.815   0.4188    
NO7                          -0.05504    1.29108  -0.043   0.9662    
NO8                          -1.48829    1.29108  -1.153   0.2541    
NO9                           0.21424    1.29108   0.166   0.8688    
Group65-79                         NA         NA      NA       NA    
TimePost 1 year              -0.44664    0.81655  -0.547   0.5866    
TimePost 6 months             0.44668    0.81655   0.547   0.5866    
TimePre OP                   -0.97777    0.81655  -1.197   0.2364    
Group65-79:TimePost 1 year    0.24482    1.15478   0.212   0.8329    
Group65-79:TimePost 6 months -0.18020    1.15478  -0.156   0.8766    
Group65-79:TimePre OP         0.72501    1.15478   0.628   0.5328    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for gaussian family taken to be 3.333764)

    Null deviance: 260.10  on 79  degrees of freedom
Residual deviance: 180.02  on 54  degrees of freedom
AIC: 345.91

Number of Fisher Scoring iterations: 2</code></pre>
</div>
</div>
<p>Group 변수에서 <strong>NA</strong>가 나왔습니다. 아마 다중공산성 문제 등이 발생해서 design matirx가 singular 해진 것 같습니다. 여기서부터 문제가 느껴지시나요? NO의 level이 너무 많아지게되어서 <strong>모델 구조가 필요 이상으로 복잡</strong>해지고, 원하지도 않은 수많은 계수들을 추정하게 됩니다. 이렇게 되면 정작 우리가 중요하게 생각하고 있는 변수들의 효과에 대한 <strong>해석도 어려워집니다.</strong></p>
<p>Group 변수에서 NA가 발생한 것 자체가 <strong>추정의 불안정성</strong>을 보여주는 예시라고 볼 수 있겠습니다. 이와 별개로 만약 반복측정된 횟수가 정말 적은 경우라면, NA가 뜨지 않더라고 해당 변수에 해당하는 표준 오차가 굉장히 커질 것이기에 값 자체에 대한 신뢰성 또한 떨어집니다.</p>
<p>이것이 우리가 lmer을 쓰는 이유 중 하나입니다. fixed effects만으로 처리하기에는 어려운 부분을 random effects로 말끔하게 처리하여 문제를 해결합니다.</p>
</section></section><section id="gee-vs-lmer" class="level1"><h1>4. GEE VS lmer</h1>
<section id="gee" class="level2"><h2 class="anchored" data-anchor-id="gee">GEE</h2>
<p>이번에는 GEE(Generaluzed Estimating Equation)를 사용해 똑같은 데이터를 분석해보겠습니다. 코드는 아래와 같습니다. 참고로 <strong>corsrt = exchangeable</strong>이라고 설정해주어 한 subject내에서 측정된 모든 관측지의 상관관계는 동일하다고 가정했습니다. GEE는 심지어 반복측정환자들끼리 잘 정리되어 있는 데이터가 아니라면 제대로 돌아가지 않습니다. 예시로 사용한 데이터는 반복측정된 환자 순서대로 잘 정리되어 있음을 밝힙니다.</p>
<div class="cell">
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">geepack</span><span class="op">)</span></span>
<span><span class="va">gee_mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/geepack/man/geeglm.html">geeglm</a></span><span class="op">(</span></span>
<span>  <span class="va">Value</span> <span class="op">~</span> <span class="va">Group</span><span class="op">*</span><span class="va">Time</span>,</span>
<span>  id        <span class="op">=</span> <span class="va">NO</span>,</span>
<span>  data      <span class="op">=</span> <span class="va">data</span>,</span>
<span>  corstr    <span class="op">=</span> <span class="st">"exchangeable"</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">gee_mod</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
geeglm(formula = Value ~ Group * Time, data = data, id = NO, 
    corstr = "exchangeable")

 Coefficients:
                             Estimate Std.err    Wald Pr(&gt;|W|)    
(Intercept)                    9.9769  0.8306 144.290   &lt;2e-16 ***
Group65-79                     0.2331  0.9386   0.062    0.804    
TimePost 1 year               -0.4466  0.9007   0.246    0.620    
TimePost 6 months              0.4467  0.4787   0.871    0.351    
TimePre OP                    -0.9778  0.8964   1.190    0.275    
Group65-79:TimePost 1 year     0.2448  1.2324   0.039    0.843    
Group65-79:TimePost 6 months  -0.1802  0.6812   0.070    0.791    
Group65-79:TimePre OP          0.7250  1.3258   0.299    0.584    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Correlation structure = exchangeable 
Estimated Scale Parameters:

            Estimate Std.err
(Intercept)    3.045  0.7025
  Link = identity 

Estimated Correlation Parameters:
      Estimate Std.err
alpha  0.01453 0.07475
Number of clusters:   20  Maximum cluster size: 4 </code></pre>
</div>
</div>
<p>lmer을 사용했을 때와 다른 점을 느끼셨나요? 두 모델 모두 <strong>estimate들의 값은 같게 나오지만, standard error의 값이 다르게 나온다</strong>는 점입니다. 두 방법 모두 반복측정자료를 분석하는데 사용되는데, 대체 어떤 차이가 있는 것일까요?</p>
<p>저는 <strong>To GEE or Not to GEE: Comparing Population Average and Mixed Models for Estimating the Associations Between Neighborhood Risk Factors and Health</strong>라는 논문에서 어느 정도 해답을 찾을 수 있었습니다.</p>
<p><strong>lmer</strong>과 같은 Mixed Model을 <strong>neighbor-specific model</strong>로 설명합니다. 이름에서 알 수 있듯이, 특정한 지역(neighbor or cluster) 혹은 객체(subject)가 각자 <strong>자신만의 고유한 반응 패턴</strong>을 가질 수 있다고 가정합니다. 결국 앞서 계속 살펴봤던 random effects model과 같은 말입니다. 각 지역(혹은 개인)마다 다른 intercept나 slope를 가질 수 있다고 가정하여 개별 단위 수준에서 추정을 진행합니다. 각 환자마다 당뇨병 치료의 영향이 다를 수 있음을 인정하는 것입니다.</p>
<p>반면, <strong>GEE</strong>와 같은 모델들은 <strong>Population-Average Model</strong>로 설명합니다. 이 경우, 각 지역이나 객체의 차이보다는 <strong>전체 모집단에서 나타나는 평균적인 관계</strong>에 더 주목합니다. 당뇨병 치료에서 어떤 요인이 한 단위 증가할 때, 어떤 환자인지는 중요하지 않고, 평균적으로 얼마나 인슐린 농도가 변하는지를 탐구하고자 하는 것입니다.</p>
<p>논문에 따르면, linear model에서 상당히 흥미로운 부분을 찾을 수 있습니다.</p>
<p><em>A simple random intercept linear model implies equal variances for all observations and equal covariances of all possible paired observations within the statistical unit (neighborhood) … This will yield the same estimates as the exchangeable working correlation model in GEE.</em></p>
<p>random intercept만을 포함하는 lmer 모델은 compound symmertry를 만족하기에 모든 관측치의 분산이 같고, 한 subject내의 모든 관측치는 동일한 상관관계를 공유합니다. 나아가 이는 GEE에서 상관구조를 ’exchangeable’로 설정했을 때의 가정과 <strong>정확히 일치</strong>합니다. 이러한 이유에서 이 둘은 동일한 회귀 계수 추정치를 내놓았던 것입니다.</p>
<p>그러나 통계적인 추론 과정에서 사용되는 standard error는 달라집니다. lmer의 경우 앞서 <span class="math inline">\(u\sim N(0, \sigma_u^2)\)</span>라고 가정한 것처럼, <strong>random effects의 분포</strong>를 가정합니다. 당연히 이 가정이 맞다는 전제에서 <strong>MLE(Maximum Likelihood Estimation)</strong>나 <strong>REML(Restrictied Maximum Likelihood)</strong>을 이용해 standard error를 계산합니다. 모델의 구조적 가정이 그대로 반영되기 때문에, 모든 시점에서 동일한 표준 오차를 내놓을 수밖에 없는 것입나다.</p>
<p>GEE의 경우 lmer과 달리 <strong>random effects의 확률적인 분포를 가정하지 않습니다</strong>. 관측된 데이터를 기반으로 <strong>robust한 standard error</strong>을 계산하는데요, 이를 <strong>sandwich estimator</strong>라고 부릅니다. 이 방식을 사용하게 되면 분포 가정에 있어 비교적 자유롭고, 설령 설정한 상관구조가 조금 잘못되었더라도 비교적 정확한 표준 오차를 제공합니다.</p>
</section><section id="blue-vs-blup" class="level2"><h2 class="anchored" data-anchor-id="blue-vs-blup">BLUE vs BLUP</h2>
<p><strong>BLUE(Best Linear Unbiased Estimator)</strong>: fixed effects에 대한 추정량입니다. 우리가 알고자 하는 모집단 전체의 평균적인 경향성을 나타내는데, 예를 들어 평균적으로 치료 수준을 한 단위 높였을 때 인슐린 농도가 어느 정도 변하는가?에 대한 답입니다. lmer과 GEE 모두 fixed effects가 존재하기에, 두 모델에서 모두 구할 수 있습니다.</p>
<p><strong>BLUP(Best Linear Unbiased Predictor)</strong>: random effects에 대한 <strong>예측치</strong>입니다. BLUE와 다르게 추정이 아니라 예측이라는 점에 주목해야 합니다. BLUE가 모집단 전체의 평균적인 경향성에 주목했다면, BLUP는 모집단 평균에서 벗어난 각 개인의 고유한 편차를 나타냅니다. 예컨대, 3번째 환자는 평균보다 얼마나 더 인슐린 농도가 늘었을까?에 대한 답입니다. random effects에 대한 부분이기에, population-average에 해당하는 GEE에서는 구할 수 없고, lmer에서만 구할 수 있습니다. 한 번 살펴 보겠습니다.</p>
<p>증명의 기초는 <strong>Henderson</strong>이 1959년에 발명한 <strong>Mixed Model Equations(MME)</strong>를 따라갑니다. 증명이 너무 길고 이해가 어려울 수도 있어 복잡한 계산 과정은 과감히 생략하도록 하겠습니다. 행렬형태의 식으로 표현하기 위해, 앞선 노테이션과 조금 다르게, <span class="math inline">\(u\)</span>의 분산-공분산 행렬을 <span class="math inline">\(G\)</span>로, <span class="math inline">\(\epsilon\)</span>의 분산-공분산 행렬은 <span class="math inline">\(R\)</span>이라고 하겠습니다.</p>
<p>lmer은 likelihood를 기반으로 작동하는 만큼, 이번에는 likelihood로 전개를 해보겠습니다.(사실 LS를 쓰나 Likelihood를 쓰나 결국 똑같은 형태가 나옵니다.) n은 전체 sample size를, r은 random effects의 차원을 의미합니다. 우선 다음과 같이 conditional 형태로 likelihood를 적어봅시다.</p>
<p><span class="math display">\[
f(Y,u) = f(Y\mid u) \cdot f(u)
\]</span> <span class="math display">\[
= \frac{1}{({2\pi})^\frac{n}{2}\det V^{1/2}} \exp(- \frac{1}{2}(Y-X\beta-Zu)^T V^{-1}\frac{1}{2}(Y-X\beta-Zu))
\]</span></p>
<p><span class="math display">\[
\times \frac{1}{({2\pi})^\frac{r}{2}\det G^{1/2}} \exp(- \frac{1}{2}u^TGu)
\]</span></p>
<p>이제 여기에 로그를 씌우게 되면 <span class="math inline">\(\beta\)</span>와 <span class="math inline">\(u\)</span> 모두에 대해 2차식으로 볼 수 있습니다. likelihood function의 concave함을 이용해 각각 <span class="math inline">\(\beta\)</span>와 <span class="math inline">\(u\)</span> 모두로 편미분을 해주고 각각 hat을 씌워주면, 아래와 같이 나타낼 수 있습니다.</p>
<p><span class="math display">\[
\begin{align*}
X^TR^{-1}X\hat{\beta} + X^TR^{-1}Z\hat{u} &amp;= X^TR^{-1}Y \\
Z^TR^{-1}X\hat{\beta} + (Z^TR^{-1}Z+G^{-1})\hat{u} &amp;= Z^TR^{-1}Y
\end{align*}
\]</span> 이제 이를 행렬 형태로 나타내면, 아래와 같이 쓸 수 있겠습니다.</p>
<p><span class="math display">\[
\begin{bmatrix}
X^T R^{-1} X &amp; X^T R^{-1} Z \\ Z^T R^{-1} X &amp; Z^T R^{-1} Z + G^{-1} \end{bmatrix} \begin{bmatrix} \hat{\beta} \\ \hat{u} \end{bmatrix} = \begin{bmatrix} X^T R^{-1} Y \\ Z^T R^{-1} Y
\end{bmatrix}
\]</span> 위 행렬식이 MME의 기본적인 형태입니다. 이를 정말 열심히 열심히 정리하면 다음과 같은 <strong>BLUE</strong>와 <strong>BLUP</strong>를 얻을 수 있습니다. <span class="math display">\[
BLUE = \hat\beta = (X^TV^{-1}X)^{-1}X^TV^{-1}Y: \text{ GLS estimator}
\]</span> <span class="math display">\[
BLUP = \hat u =GZ^TV^{-1}(Y-X\hat\beta)
\]</span></p>
<p>여기서 한 가지 의문이 들 수 있는데요, 일반적으로 <strong>Gauss-Markov Theorem</strong>을 만족할 때 OLS를 통해 구한 estimator가 <strong>unbiased</strong>하고 <strong>가장 작은 분산</strong>을 갖기에 <strong>BLUE</strong>라고 부릅니다. 반복측정자료는 같은 subject에서 측정된 데이터 간 상관관계가 존재하기 때문에 <strong>일반적으로 Gauss-Markov Theorem을 만족하지 않습니다</strong>. 그렇다면 과연 lmer을 통해 구한 <span class="math inline">\(\hat\beta_{GLS}\)</span>는 BLUE가 맞을까요? <strong>놀랍게도 맞습니다.</strong> 간단하게만 알아보면, Least Square을 일반화해서 GLS를 진행한 것처럼, Gauss-Markov Theorem을 일반화한 <strong>Aitken’s Theorem</strong>이 존재합니다! 이 정리를 통해 GLS estimator가 BLUE임을 보일 수 있습니다. 간단한 증명은 다음과 같습니다.</p>
<p>우선 <strong>unbiasedness</strong>부터 보면, <span class="math display">\[
E[\hat\beta_{GLS}] = E[(X^TV^{-1}X)^{-1}X^TV^{-1}(X\beta+\epsilon^*)]
\]</span></p>
<p><span class="math display">\[
= E[(X^TV^{-1}X)^{-1}X^TV^{-1}X] + E[(X^TV^{-1}X)^{-1}X^TV^{-1}\epsilon^*]
\]</span></p>
<p><span class="math display">\[
= E[\beta] + (X^TV^{-1}X)^{-1}X^TV^{-1} \times E[\epsilon^*] = \beta
\]</span> 이렇게 쉽게 unbiasedness를 보일 수 있습니다. 나아가 분산을 보겠습니다. <span class="math inline">\(b\)</span>를 또다른 linear unbiased estimator로 이면서 다음과 같은 형태를 만족한다고 해봅시다. <span class="math display">\[
b = [(X^TV^{-1}X)^{-1}X^TV^{-1} + A]Y
\]</span> unbiasedness를 만족해야 하기 때문에, 계산을 해보면 <span class="math inline">\(AX =0\)</span>이 되어야 합니다. 그렇다면 분산을 구해보면, <span class="math display">\[
Var(b)= [(X^TV^{-1}X)^{-1}X^TV^{-1} + A] V [(X^TV^{-1}X)^{-1}X^TV^{-1} + A]^{-1}
\]</span> <span class="math display">\[
= (X^TV^{-1}X)^{-1} + AVA^T +(X^TV^{-1}X)^{-1}X^TA^T + AX(X^TV^{-1}X)^{-1}
\]</span> <span class="math display">\[
= (X^TV^{-1}X)^{-1} + AVA^T (\because \ AX = 0)
\]</span> <span class="math display">\[
\geq (X^TV^{-1}X)^{-1} (\because \ V \text{ is psd})
\]</span> <span class="math display">\[
= Var(\hat\beta_{GLS})
\]</span></p>
<p>따라서 <span class="math inline">\(\hat\beta_{GLS}\)</span>$가 <span class="math inline">\(BLUE\)</span>가 됨을 보일 수 있습니다. BLUP 또한 BLUE와 비슷한 방법으로 또다른 linear unbiased parameter을 들고 와서 증명이 가능합니다. BLUP의 형태를 다시 한 번 보겠습니다.</p>
<p><span class="math display">\[
BLUP = \hat u =GZ^TV^{-1}(Y-X\hat\beta)
\]</span> 이제 이 식을 우리가 계속 다뤘던 intercept에만 random effects가 존재하는 모델에 맞추어 바꿔보도록 하겠습니다. <span class="math inline">\(G\)</span> 또한 원래의 노테이션으로 바꿔서 i번째 환자의 입장에서 정리해보면 다음과 같이 표현할 수 있겠습니다.</p>
<p><span class="math display">\[
\hat u_i = (\frac{n_i \sigma_u ^2}{n_i \sigma_u^2 + \sigma^2}) \times \frac{1}{n_i} \sum_{j=1}^{n_i}(y_{ij}-x_{ij}^T\hat\beta)
\]</span> 이렇게 간단한게 스칼라 형태로 정리 되는데요, 이 식이 가지는 의미는 무엇일까요?</p>
<p>우선 뒷부분부터 보면 우리가 평소에 회귀분석에서 볼 수 있는 <strong>잔차의 평균</strong> 형태입니다. i번째 환자가 평균적으로 예측에서 얼마나 벗어나있는지에 대해 알려주는 정보로 해석할 수 있습니다. 또한 일반적인 선형 회귀 모델과 다르게 우리 모델은 <span class="math inline">\(Zu\)</span>라는 random effects를 표현하는 term이 존재했으므로, 이 부분을 fixed effects의 효과를 제거하고 random effects와 <span class="math inline">\(\epsilon\)</span>에 해당하는 error만 남긴 부분으로 볼 수도 있습니다.</p>
<p>첫번째 부분이 BLUP의 핵심이라고 볼 수 있습니다. 이는 가중치의 형태로 <strong>수축(Shrinkage) 효과</strong>를 보여주는데요, 직관적으로 <span class="math inline">\(n_i\)</span>의 값이 커지거나 <span class="math inline">\(\sigma_u^2\)</span> 커질수록 이 값은 1에 가까워집니다. 각 환자의 데이터가 많거나 환자 내에서 측정한 데이터끼리의 상관관계가 강할수록 가중치가 1에 가까워져 각 환자의 평균 잔차를 더 신뢰하는 형태가 됩니다. 반대로, 0에 가까울수록 각 환자의 데이터보다는 전체 평균에 가까워지도록 예측치를 수축시킵니다.</p>
<p>결국 BLUP는 각 환자의 <strong>반복측정된 데이터의 수</strong>와 그 데이터끼리 <strong>상관된 정도</strong>에 따라 어떻게 예측을 진행할지를 결정해준다고 볼 수 있습니다. 데이터가 부족한 상황에서는 예측이 불확실한 노이즈에 과도하게 영향을 받는 것을 막고, 전체 데이터의 정보에 따라 안정적이고 보수적인 예측을 가능하게 해준다는 점에서 의미가 있습니다.</p>
<p>lmer은 모집단의 전반적인 경향성뿐만 아니라 그 안에서 개개인이 얼마나 다양한 패턴을 보여주는지 또한 제시할 수 있다는 점에서 GEE와는 다른 차별점을 가진다고 할 수 있겠습니다.</p>
</section></section><section id="마치며" class="level1"><h1>마치며</h1>
<p>결국 lmer에서 intercept에만 random effects가 존재할 때 추정치들의 표준 오차가 같아지는 현상은 무언가 잘못된 것이 아니라, 모델 구조상 자연스러운 결과입니다. 반복측정자료 연구에서 주된 관심사가 개체간 변동성을 고려하는 즉, subject(neighbor)-specific하다면, 이는 받아들일 수 있는 결과입니다.</p>
<p>다만, 전체 집단의 평균적인 변화에 관심이 있다면 GEE와 같은 population-average 모델이 더 좋은 방법이 될 수 있습니다. random effects의 분포를 가정하지 않으면서 robust한 추정량을 제공하는 GEE가 대안이 될 수도 있습니다.</p>
<p>결국 가장 중요한 것은 <strong>내가 지금 무엇을 하고 있는지에 대해 정확히 아는 것</strong>입니다. 이 질문에 대해 정확히 대답할 수 있어야 이에 따라 적합한 모델과 그 결과에 대한 올바른 해석을 할 수 있을 것입니다.</p>


</section><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{jee2025,
  author = {Jee, Mingu},
  title = {반복측정자료 {모델링:} Linear Mixed Effects Model},
  date = {2025-08-12},
  url = {https://blog.zarathu.com/posts/2025-08-08-lmer and gee/},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-jee2025" class="csl-entry quarto-appendix-citeas" role="listitem">
Jee, Mingu. 2025. <span>“반복측정자료 모델링: Linear Mixed Effects
Model.”</span> August 12, 2025. <a href="https://blog.zarathu.com/posts/2025-08-08-lmer and gee/">https://blog.zarathu.com/posts/2025-08-08-lmer
and gee/</a>.
</div></div></section></div></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/blog\.zarathu\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><script src="https://giscus.app/client.js" data-repo="zarathucorp/giscus-blog" data-repo-id="R_kgDOHztuxg" data-category="General" data-category-id="DIC_kwDOHztuxs4CQ6h5" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script><input type="hidden" id="giscus-base-theme" value="light"><input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
<p>Powered by <a href="https://quarto.org">Quarto</a>.</p>
</div>   
    <div class="nav-footer-center">
<p>© 2019. <a href="https://www.zarathu.com">Zarathu Co.,Ltd.</a> All rights reserved. Licence: <a href="https://opensource.org/license/mit-0/">MIT</a>.</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>


<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>